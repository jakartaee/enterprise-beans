[[a384]]
== Enterprise Beans 2.1 Entity Bean Component Contract for Container-Managed Persistence

The Enterprise Beans 2.1 entity bean component contract for container-managed persistence is the contract between an entity bean and its container.
It defines the life cycle of the entity bean instances, the model for method delegation of the business methods invoked by the client, and the model for the management of the entity bean’s persistent state and relationships.
The main goal of this contract is to ensure that an entity bean component using container-managed persistence is portable across all compliant Enterprise Beans containers.

This chapter defines the Enterprise Bean Provider’s view of this contract and responsibilities of the Container Provider for managing the life cycle of the enterprise bean instances and their persistent state and relationships.

_Note that use of dependency injection, interceptors, and Java language metadata annotations is not supported for Enterprise Beans 2.1 entity beans._

=== Overview

In accordance with the architecture for container-managed persistence, the Bean Provider develops a set of entity beans for an application, and determines the relationships among them.
The Bean Provider designs an abstract persistence schema for each entity bean, which defines its container-managed fields and relationships, and determines the methods for accessing them.
The entity bean instance accesses its container-managed fields and relationships at runtime by means of the methods defined for its abstract persistence schema.

The abstract persistence schema is specified in the deployment descriptor that is produced by the Bean Provider.
The Deployer, using the Container Provider’s tools, determines how the persistent fields and relationships defined by the abstract persistence schema are mapped to a database or other persistent store, and generates the necessary additional classes and interfaces that enable the container to manage the persistent fields and relationships of the entity bean instances at runtime.

This chapter describes the component contract for an Enterprise Beans 2.1 entity bean with container-managed persistence, and how data independence is maintained between the entity bean instance and its representation in the persistent store.
It describes this contract from the viewpoints of both the Bean Provider and the container.

=== Container-Managed Entity Persistence and Data Independence

The Enterprise Beans component model provides a separation between the client view of a bean (as presented by its home and component interfaces) and the entity bean class (which provides the implementation of the client view).
The Enterprise Beans architecture for container-managed persistence adds to this a separation between the entity bean class (as defined by the Bean Provider) and its persistent representation.
The container-managed persistence architecture thus provides not only a layer of data independence between the client view of a bean as an _entity object_ and the Bean Provider’s internal view of the bean in terms of the entity bean instance, but also between the entity bean instance and its persistent representation.
This allows an entity bean to be evolved independently from its clients, without requiring the redefinition or recompilation of those clients, and it allows an entity bean to be redeployed across different containers and different persistent data stores, without requiring the redefinition or recompilation of the entity bean class.

In container-managed persistence, unlike in bean-managed persistence, the Bean Provider does not write database access calls in the methods of the entity bean class.
Instead, persistence is handled by the container at runtime. The entity Bean Provider must specify in the deployment descriptor those persistent fields and relationships for which the container must handle data access. 
The Bean Provider codes all persistent data access by using the accessor methods that are defined for the abstract persistence schema.
The implementation of the persistent fields and relationships, as well as all data access, is deferred to the container.

It is the responsibility of the Deployer to map the abstract persistence schema of a set of interrelated entity bean classes into the physical schema used by the underlying data store (e.g., into a relational schema) by using the Container Provider’s tools.
The Deployer uses the deployment descriptor as input to the Container Provider’s tools to perform this mapping.
The Container Provider’s tools are also used to generate the concrete implementation of the entity bean classes, including the code that delegates calls to the accessor methods of the entity bean class to the runtime persistent data access layer of the container.

The Enterprise Beans deployment descriptor for Enterprise Beans 2.1 entity beans describes _logical_ relationships among entity beans.
It does not provide a mechanism for specifying how the abstract persistence schema of an entity bean or of a set of interrelated entity beans is to be mapped to an underlying database.
This is the responsibility of the Deployer, who, using the Container Provider’s tools, uses the logical relationships that are specified in the deployment descriptor to map to the physical relationships that are specific to the underlying resource.
It is the responsibility of the container to manage the mapping between the logical and physical relationships at runtime and to manage the referential integrity of the relationships.

The advantage of using container-managed persistence is that the entity bean can be logically independent of the data source in which the entity is stored.
The Container Provider’s tools can, for example, generate classes that use JDBC or SQLJ to access the entity state in a relational database; classes that implement access to a non-relational data source, such as an IMS database; or classes that implement function calls to existing enterprise applications. These tools are typically specific to each data source.

.View of Underlying Data Sources Accessed Through Entity Bean
image:EBOpt-8.png[]

=== The Entity Bean Provider’s View of Container-Managed Persistence

An entity bean implements an object view of a business entity or set of business entities stored in an underlying database or implemented by an existing enterprise application (for example, by a mainframe program or by an ERP application).

An entity bean with container-managed persistence typically consists of its entity bean class; a component interface which defines its client view business methods; a home interface which defines the create, remove, home, and finder methods of its client view; and its abstract persistence schema as specified in the deployment descriptor.

A client of an entity bean can control the life cycle of a bean by using the bean’s home interface and can manipulate the bean as a business entity by using the methods defined by its component interface.
The home and component interfaces of a bean define its client view.

An entity bean with container-managed persistence typically has container-managed relationships with other container-managed persistence entity beans, as defined by the `relationships`  element of
the deployment descriptor.
The architecture for container-managed persistence thus allows the Bean Provider to implement complex applications by defining a complex abstract persistence schema encompassing multiple entity bean classes related by means of container-managed relationships.

An entity bean accesses related entity beans by means of the accessor methods for its container-managed relationship fields, which are specified by the `cmr-field`  elements of its abstract persistence schema defined in the deployment descriptor.
Entity bean relationships are defined in terms of the local interfaces of the related beans, and the view an entity bean presents to its related beans is defined by its local home and local interfaces. Thus, an entity bean can be the target of a relationship from another entity bean only if it has a local interface.

The Bean Provider programming an application that uses container-managed persistence typically avoids calls to the methods of the remote home and remote interfaces in favor of invoking related beans by means of the methods of their local interfaces.
Unlike remote method calls, such internal method invocations are made using call-by-reference and commonly do not involve the checking of method permissions.

The Enterprise Beans architecture for container-managed persistence provides great flexibility to the Bean Provider in designing an application.

****
_For example, a group of related entity beans—`Order`, `LineItem` and `Customer`—might all be defined as having only local interfaces, with a remotable session bean containing the business logic that drives their invocation.
The individual entity beans form a coordinated whole that provides an interrelated set of services that are exposed by their several home and component interfaces.
The services provided by the local network of entity beans is exposed to the remote client view through the home and remote interfaces of the session bean, which offers a coarser grained remote service._

_Alternatively, a single entity bean might represent an independent, remotable business object that forms a unit of distribution that is designed to be referenced remotely by multiple enterprise beans and/or other remote clients.
Such a remotable entity bean might make use of other entity beans within its local scope to further model its complex internal state.
For example, an `Order` entity bean might make use of a `LineItem` entity bean internally, not exposing it to remote clients.
In this case, the `Order` entity bean might define both a remote and a local component interface, where the local interface is presented only to the related entity beans, such as `LineItem`, and the remote interface is presented to session beans and/or web-tier clients._
****

==== The Entity Bean Provider’s Programming Contract

The Bean Provider must observe the following programming contract when defining an entity bean class that uses container-managed persistence:

* The Bean Provider must define the entity bean class as an abstract class.
The container provides the implementation class that is used at runtime.

* The container-managed persistent fields and container-managed relationship fields must _not_ be defined in the entity bean class.
From the perspective of the Bean Provider, the container-managed persistent fields and container-managed relationship fields are virtual fields only, and are accessed through get and set accessor methods.
The implementation of the container-managed persistent fields and container-managed relationship fields is supplied by the container.

* The container-managed persistent fields and container-managed relationship fields must be specified in the deployment descriptor using the `cmp-field` and `cmr-field` elements respectively.
The names of these fields must be valid Java identifiers and must begin with a lowercase letter, as determined by `java.lang.Character.isLowerCase`.

* The Bean Provider must define the accessor methods for the container-managed persistent fields and container-managed relationship fields as get and set methods, using the JavaBeans conventions. The implementation of the accessor methods is supplied by the container.

* The accessor methods must be public, must be abstract, and must bear the name of the container-managed persistent field (`cmp-field`) or container-managed relationship field (`cmr-field`) that is specified in the deployment descriptor, and in which the first letter of the name of the cmp-field or cmr-field has been uppercased and prefixed by "```get```" or "```set```".

* The accessor methods for a container-managed relationship field must be defined in terms of the local interface of the related entity bean, as described in <<a437>>.

* The accessor methods for container-managed relationship fields for one-to-many or many-to-many relationships must utilize one of the following Collection interfaces: `java.util.Collection` or `java.util.Set`.
The Collection interfaces used in relationships are specified in the deployment descriptor.
The implementation of the collection classes used for the container-managed relationship fields is supplied by the container.

* An entity bean local interface type (or a collection of such) can be the type of a cmr-field. An entity bean local interface type (or a collection of such) cannot be the type of a cmp-field.

* The accessor methods for the container-managed relationship fields must not be exposed in the remote interface of an entity bean.

* The local interface types of the entity bean and of related entity beans must not be exposed through the remote interface of the entity bean.

* The collection classes that are used for container-managed relationships must not be exposed through the remote interface of the entity bean.

* Once the primary key for an entity bean has been set, the Bean Provider must not attempt to change it by use of set accessor methods on the primary key cmp-fields.
The Bean Provider should therefore not expose the set accessor methods for the primary key cmp-fields in the component interface of the entity bean.

* The Bean Provider must ensure that the Java types assigned to the cmp-fields are restricted to the following: Java primitive types and Java serializable types.

[[a437]]
==== The Entity Bean Provider’s View of Persistent Relationships

An entity bean may have relationships with other entity beans with container-managed persistence.

Relationships may be one-to-one, one-to-many, or many-to-many relationships.

Container-managed relationships can exist only among entity beans within the same local relationship scope, as defined by the `relationships` element in the deployment descriptor.
Container-managed relationships are defined in terms of the local interfaces of the related beans.

Relationships may be either bidirectional or unidirectional.
If a relationship is bidirectional, it can be navigated in both directions, whereas a unidirectional relationship can be navigated in one direction only.

A unidirectional relationship is implemented with a cmr-field on the entity bean instance from which navigation can take place, and no related cmr-field on the entity bean instance that is the target of the relationship.
Unidirectional relationships are typically used when the Bean Provider wishes to restrict the visibility of a relationship.

An entity bean that does not have a local interface can have only unidirectional relationships from itself to other entity beans.
The lack of a local interface prevents other entity beans from having a relationship to it.

The bean developer navigates or manipulates relationships by using the get and set accessor methods for the container-managed relationship fields and the `java.util.Collection` API for collection-valued container-managed
relationship fields.

The Bean Provider must consider the type and cardinality of relationships when the entity bean classes are programmed.
The get method for a cmr-field must return either the local interface of the entity bean or a collection (either `java.util.Collection` or `java.util.Set`) of the same.
The set method for the relationship must take as an argument the entity bean’s local interface or a collection of the same.

==== Dependent Value Classes

A dependent value class is a concrete class that is the value of a cmp-field.
A dependent value class may be a class that the Bean Provider wishes to use internally within an entity bean with container-managed persistence, and/or it may be a class that the Bean Provider chooses to expose through the remote (or local) interface of the entity bean.

A dependent value class can be the value of a cmp-field; it cannot be the value of a cmr-field.

The get accessor method for a cmp-field that corresponds to a dependent value class returns a _copy_ of the dependent value class instance.
The assignment of a dependent value class value to a cmp-field using the set accessor method causes the value to be copied to the target cmp-field.

A dependent value class must be serializable.
The internal structure of a dependent value class is not described in
the Enterprise Beans deployment descriptor.

==== Remove Protocols

The Bean Provider can specify the removal of an entity object in two ways:

* By the use of a `remove` method on the entity bean’s component interface or home interface.

* By the use of a `cascade-delete` specification in the deployment descriptor.

===== Remove Methods

When the `remove` method is invoked on an entity object, the container must invoke the entity Bean Provider’s `ejbRemove` method as described in <<a1279>>.
After the Bean Provider’s `ejbRemove` method returns (and prior to returning to the client), the container must remove the entity object from all relationships in which it participates, and then remove its persistent
representation.
footnote:a3368[At this point it must appear to the application that the entity has been removed from the persistent store. If the container employs an optimistic caching strategy and defers the removal of the entity from the database (e.g., to the end of transaction), this must be invisible to the application.]

* Once an entity has been removed from a relationship, the accessor methods for any relationships to the entity will reflect this removal.
An accessor method for a one-to-one or many-to-one relationship to the entity will return null; and an accessor method for a many-to-many relationship to the entity will return a collection from which the entity object has been removed.

* The container must detect any subsequent attempt to invoke an accessor method on the removed entity object and throw the `java.rmi.NoSuchObjectException` if the client is a remote client or the `jakarta.ejb.NoSuchObjectLocalException` if the client is a local client.
The container must detect an attempt to assign a removed entity object as the value of a cmr-field of another object (whether as an argument to a set accessor method or as an argument to a method of the `java.util.Collection` API) and throw the `java.lang.IllegalArgumentException`.

After removing the entity object from all relationships and removing its persistent representation, the container must then cascade the removal to all entity beans with which the entity had been previously in container-managed relationships for which the `cascade-delete` option was specified.

More than one relationship may be affected by the removal of an entity object, as in the following example.
Once the shipping address object used by the `Order` bean has been removed, the billing address accessor method will also return null.
[source, java]
----
public void changeAddress()
    Address a = createAddress();
    setShippingAddress(a);
    setBillingAddress(a);
    //both relationships now reference the same entity object
    getShippingAddress().remove();
    if (getBillingAddress() == null) // it must be
        ...
    else ...
         // this is impossible....
----

The `remove` method, alone, causes only the entity on which it is invoked to be removed.
It does not cause the deletion to be cascaded to other entity objects.
In order for the deletion of one entity object to be automatically cascaded to another, the `cascade-delete` mechanism should be used.

===== Cascade-delete

The `cascade-delete` deployment descriptor element is used within a particular relationship to specify that the lifetime of one or more entity objects is dependent upon the lifetime of another entity object.

The `cascade-delete` deployment descriptor element is contained within the `ejb-relationship-role` element.
The `cascade-delete` element can only be specified for an `ejb-relationship-role` element contained in an `ejb-relation` element if the _other_ `ejb-relationship-role` element in the same `ejb-relation` element specifies a `multiplicity` of `One`.
The `cascade-delete` option cannot be specified for a many-to-many relationship.
The deletion of one entity object can only be cascaded to cause the deletion of other entity objects if the first entity object is in a one-to-one or one-to-many relationship with those other entity objects.

If an entity is deleted, and the `cascade-delete` deployment descriptor element is specified for a related entity bean, then the removal is cascaded to cause the removal of the related entity object or objects.
As with the `remove` operation, the removal triggered by the `cascade-delete` option causes the container to invoke the `ejbRemove` method on the entity bean instance that is to be removed before the persistent representation of that entity object is removed.
Once an entity has been removed from a relationship because of a cascaded delete, the accessor methods for any relationships to the entity will reflect this removal.
An accessor method for a one-to-one or many-to-one relationship to the entity will return null; and an accessor method for a many-to-many relationship to the entity will return a collection from which the entity object has been removed.
After removing the entity object from all relationships and removing its persistent representation, the container must then cascade the removal to all entity beans with which the entity had been previously been in container-managed relationships for which the `cascade-delete` option was specified.

The use of `cascade-delete` causes only the entity object or objects in the relationship for which it is specified to be deleted.
It does not cause the deletion to be further cascaded to other entity objects, unless they are participants in relationship roles for which `cascade-delete` has also been specified.

==== Identity of Entity Objects

From the viewpoint of the Bean Provider, entity objects have a runtime object identity that is maintained by the container.

The container maintains the persistent identity of an entity object on the basis of its primary key.

The primary key of an entity bean may or may not be visible as one or more cmp-fields of the instance, depending on the way in which it is specified. The Bean Provider specifies the primary key as described in <<a1820>>.
Once it has been set, the Bean Provider must not attempt to change the value of a primary key field by means of a set method on its cmp-fields.

When a new instance of an entity bean whose primary key fields are visible in the entity bean class is created, the Bean Provider must use the `ejbCreate<METHOD>` method to set all the primary key fields of the entity bean instance before the instance can participate in a relationship, e.g. be used in a set accessor method for a cmr-field.
The Bean Provider must not reset a primary key value by means of a set method on any of its cmp-fields after it has been set in the `ejbCreate<METHOD>` method.
If the Bean Provider attempts to reset a primary key value, the container must throw the `java.lang.IllegalStateException`.

****
_Note that the container’s implementation of the referential integrity semantics for container-managed relationships must not cause the value of the primary key to change._

_The Bean Provider should not use untrimmed or blank-padded string-valued primary key fields. Use of untrimmed primary key fields may cause comparison operations based on primary keys to fail, and may result in non-portable behavior.
If untrimmed strings are used in primary key fields or other cmp-fields, the container or database system may trim them._
****

[[a496]]
==== Semantics of Assignment for Relationships

The assignment operations for container-managed relationships have a special semantics that is determined by the referential integrity semantics for the relationship multiplicity.

In the case of a one-to-one relationship, when the Bean Provider uses a set accessor method to assign an object from a cmr-field in one instance to a cmr-field of the _same relationship type_ (i.e., as defined by the `ejb-relation` and `ejb-relationship-role` deployment descriptor elements) in another instance, the object is effectively _moved_ and the value of the source cmr-field is set to null in the same transaction context.
If the argument to the set accessor method is not of the same type as the cmr-field, the container must throw the `java.lang.IllegalArgumentException`.

In the case of a one-to-many or many-to-many relationship, either the `java.util.Collection` API or a set accessor method may be used to manipulate the contents of a collection-valued cmr-field.
These two approaches are discussed below.

===== Use of the java.util.Collection API to Update Relationships

The methods of the `java.util.Collection` API for the container-managed collections used for collection-valued cmr-fields have the usual semantics, with the following exception: the `add` and `addAll` methods applied to container-managed collections in one-to-many relationships have a special semantics that is determined by the referential integrity of one-to-many relationships.

* If the argument to the `add` method is already an element of a collection-valued relationship field of the _same relationship type_ as the target collection (as defined by the `ejb-relation` and `ejb-relationship-role` deployment descriptor elements), it is removed from this first relationship and added, in the same transaction context, to the target relationship (i.e., it is effectively moved from one collection of the relationship type to the other).
For example, if there is a one-to-many relationship between field offices and sales representatives, adding a sales representative to a new field office will have the effect of removing him or her from his or her current field office.
If the argument to the `add` method is not an element of a collection-valued relationship of the _same relationship type_, it is simply added to the target collection and not removed from its current collection, if any.

* The `addAll` method, when applied to a target collection in a one-to-many relationship, has similar semantics, applied to the members of its collection argument individually.

****
_Note that in the case of many-to-many relationships, adding an element or elements to the contents of a collection-valued cmr-field has no effect on the source collection, if any._
_For example, if there is a many-to-many relationship between customers and sales representatives, a customer can be added to the set of customers handled by a particular sales representative without affecting the set of customers handled by any other sales representative._
****

When the `java.util.Collection` API is used to manipulate the contents of container-managed relationship fields, the argument to any Collection method defined with a single Object parameter must be of the element type of the collection defined for the target cmr-field.
The argument for any collection-valued parameter must be a `java.util.Collection` (or `java.util.Set`), all of whose elements are of the element type of the collection defined for the target cmr-field.
If an argument is not of the correct type for the relationship, the container must throw the `java.lang.IllegalArgumentException`.

The Bean Provider should exercise caution when using an Iterator over a collection in a container-managed relationship.
In particular, the Bean Provider should not modify the container-managed collection while the iteration is in progress in any way that causes elements to be added or removed, other than by the `java.util.Iterator.remove()` method.
If elements are added or removed from the underlying container-managed collection used by an iterator other than by the `java.util.Iterator.remove()` method, the container should throw the `java.lang.IllegalStateException` on the next operation on the iterator.

The following example illustrates how operations on container-managed relationships that affect the contents of a collection-valued cmr-field viewed through an iterator can be avoided.
Because there is a one-to-many relationship between field offices and sales representatives, adding a sales representative to a new field office causes the sales representative to be removed from the current field office.
[source, java]
----
Collection nySalesreps = nyOffice.getSalesreps();
Collection sfSalesreps = sfOffice.getSalesreps();

Iterator i = nySalesreps.iterator();
Salesrep salesrep;

// a wrong way to transfer the salesrep
while (i.hasNext()) {
    salesrep = (Salesrep)i.next();
    sfSalesreps.add(salesrep); // removes salesrep from nyOffice
}

// this is a correct and safe way to transfer the salesrep
while (i.hasNext()) {
    salesrep = (Salesrep)i.next();
    i.remove();
    sfSalesreps.add(salesrep);
}
----

===== Use of Set Accessor Methods to Update Relationships

The semantics of a set accessor method, when applied to a collection-valued cmr-field, is also determined by the referential integrity semantics associated with the multiplicity of the relationship.
The identity of the collection object referenced by a cmr-field does not change when a set accessor method is executed.

In the case of a one-to-many relationship, if a collection of entity objects is assigned from a cmr-field of in one instance to a cmr-field of the same relationship type in another instance, the objects in the collection are effectively moved.
The contents of the collection of the target instance are replaced with the contents of the collection of the source instance, but the _identity_ of the collection object containing the instances in the relationship does not change.
The source cmr-field references the same collection object as before (i.e., the identity of the collection object is preserved), but the collection is empty.

The Bean Provider can thus use the set method to move objects between the collections referenced by cmr-fields of the same relationship type in different instances.
The set accessor method, when applied to a cmr-field in a one-to-many relationship thus has the semantics of the `java.util.Collection` methods `clear`, followed by `addAll`, applied to the target collection; and `clear`, applied to the source collection.
It is the responsibility of the container to transfer the contents of the collection instances in the same transaction context.

****
_Note that if the collection that is passed to the cmr setter method is an unmanaged collection (i.e., not itself the value of a collection-valued cmr-field), the same requirements apply in the case that the collection contains entity objects that already participate in a one-to-many relationship of the same relationship type as the target cmr-field._
****

In the following example, the telephone numbers associated with the billing address of an `Order` bean instance are transferred to the shipping address.
Billing address and shipping address are different instances of the same local interface type, `Address`.
`Address` is related to `TelephoneNumber` in a one-to-many relationship.
The example illustrates how a Bean Provider uses the set method to move a set of instances.
[source, java]
----
public void changeTelephoneNumber() {
    Address a = getShippingAddress();
    Address b = getBillingAddress();
    Collection c = b.getTelephoneNumbers();
    a.setTelephoneNumbers(b.getTelephoneNumbers());
    if (c.isEmpty()) { // must be true...
     ...
    }
}
----

In the case of a many-to-many relationship, if the value of a cmr-field is assigned to a cmr-field of the same relationship type in another instance, the objects in the collection of the first instance are assigned as the contents of the cmr-field of the second instance.
The identities of the collection objects referenced by the cmr-fields do not change.
The contents of the collections are shared, but not the collections themselves.
The set accessor method, when applied to a cmr-field in a many-to-many relationship thus has the semantics of the `java.util.Collection` methods `clear`, followed by `addAll`, applied to the target collection.

For example, if there is a many-to-many relationship between customers and sales representatives, assigning the set of customers of one sales representative to the another sales representative will result in both sales representatives handling the same customers.
If the second sales representative originally handled a different group of customers, those customers will no longer be handled by that sales representative.
[source, java]
----
public void shareCustomers(SalesRep rep) {
    setCustomers(rep.getCustomers());
    // the customers are shared among the sales reps
}
----

The following section, <<a558>>, defines the semantics of assignment for relationships in further detail.

[[a558]]
==== Assignment Rules for Relationships

This section
defines the semantics of assignment and collection manipulation in
one-to-one, one-to-many, and many-to-many container-managed
relationships.

The figures make
use of two entity beans, with local interface types A and B. Instances
with local interface type _A_ are typically designated as _a1_ ,...,
_an_ ; instances with local interface type _B_ are typically designated
as _b1_ ,..., _bm_ . Interface _A_ exposes accessor methods _getB_ and
_setB_ for navigable relationships with _B_ : _getB_ returns an instance
of _B_ or a collection of instances of _B_ , depending on the
multiplicity of the relationship. Similarly, _B_ exposes accessor
methods _getA_ and _setA_ for navigable relationships with _A_ .

All changes in each subsection are assumed to
be applied to the figure labeled “Before change” at the beginning of the
subsection (i.e., changes are not cumulative). The results of changes
are designated graphically as well as in conditional expressions
expressed in the Java _TM_ programming language.

===== One-to-one Bidirectional Relationships



image:EBOpt-9.png[image]

Before change:

B b1 = a1.getB();

B b2 = a2.getB();

Change:

 _a1.setB(a2.getB());_

Expected result:

(b2.isIdentical(a1.getB())) &&

(a2.getB() == null) &&

(b1.getA() == null) &&

(a1.isIdentical(b2.getA()))



image:EBOpt-10.png[image]

===== One-to-one Unidirectional Relationships



image:EBOpt-11.png[image]

Before change:

B b1 = a1.getB();

B b2 = a2.getB();

Change:

 _a1.setB(a2.getB());_

Expected result:

 _(b2.isIdentical(a1.getB())) && (_ a2.getB()
=== null)



image:EBOpt-12.png[image]

===== One-to-many Bidirectional Relationships



image:EBOpt-13.png[image]

Before change:

Collection b1 = a1.getB();

Collection b2 = a2.getB();

B b11, b12, ... , b1n; // members of b1

B b21, b22, ... , b2m; // members of b2



Change:

 _a1.setB(a2.getB());_

Expected result:

(a2.getB().isEmpty()) &&

(b2.isEmpty()) &&

(b1 == a1.getB()) &&

(b2 == a2.getB()) &&

(a1.getB().contains(b21)) &&

(a1.getB().contains(b22)) && ... &&

(a1.getB().contains(b2m)) &&

(b11.getA() == null) &&

(b12.getA() == null) && ... &&

(b1n.getA() == null) &&

(a1.isIdentical(b21.getA())) &&

(a1.isIdentical(b22.getA())) && ...&&

(a1.isIdentical(b2m.getA()))



image:EBOpt-14.png[image]

Change:

 _b2m.setA(b1n.getA());_

Expected result:

(b1.contains(b11)) &&

(b1.contains(b12)) && ... &&

(b1.contains(b1n)) &&

(b1.contains(b2m)) &&

(b2.contains(b21)) &&

(b2.contains(b22)) && ... &&

(b2.contains(b2m_1)) &&

(a1.isIdentical(b11.getA())) &&

(a1.isIdentical(b12.getA())) && ... &&

(a1.isIdentical(b1n.getA())) &&

(a2.isIdentical(b21.getA())) &&

(a2.isIdentical(b22.getA())) && ... &&

(a2.isIdentical(b2m_1.getA())) &&

(a1.isIdentical(b2m.getA()))



image:EBOpt-15.png[image]

Change:

a1.getB().add(b2m);

Expected result:

(b1.contains(b11)) &&

(b1.contains(b12)) && ... &&

(b1.contains(b1n)) &&

(b1.contains(b2m)) &&

(b2.contains(b21)) &&

(b2.contains(b22)) && ... &&

(b2.contains(b2m_1)) &&

(a1.isIdentical(b11.getA())) &&

(a1.isIdentical(b12.getA())) && ... &&

(a1.isIdentical(b1n.getA())) &&

(a2.isIdentical(b21.getA())) &&

(a2.isIdentical(b22.getA())) && ... &&

(a2.isIdentical(b2m_1.getA())) &&

(a1.isIdentical(b2m.getA()))



image:EBOpt-16.png[image]

Change:

a1.getB().remove(b1n);

Expected result:

(b1n.getA() == null) &&

(b1 == a1.getB()) &&

(b1.contains(b11)) &&

(b1.contains(b12)) && ... &&

(b1.contains(b1n_1)) &&

!(b1.contains(b1n))



image:EBOpt-17.png[image]

===== One-to-many Unidirectional Relationships



image:EBOpt-18.png[image]

Before change:

Collection b1 = a1.getB();

Collection b2 = a2.getB();

B b11, b12, ... , b1n; // members of b1

B b21, b22, ... , b2m; // members of b2

Change:

 _a1.setB(a2.getB());_

Expected result:

(a2.getB().isEmpty()) &&

(b2.isEmpty()) &&

(b1 == a1.getB()) &&

(b2 == a2.getB()) &&

(a1.getB().contains(b21)) &&

(a1.getB().contains(b22)) && ... &&

(a1.getB().contains(b2m))



image:EBOpt-19.png[image]

Change:

a1.getB().add(b2m);

Expected result:

(b1 == a1.getB()) &&

(b1.contains(b2m))



image:EBOpt-20.png[image]

Change:

a1.getB().remove(b1n);

Expected result:

(a1.getB().contains(b11)) &&

(a1.getB().contains(b12)) && ... &&

(a1.getB().contains(b1n_1)) &&

!(a1.getB().contains(b1n)) &&



image:EBOpt-21.png[image]

===== Many-to-one Unidirectional Relationships



image:EBOpt-22.png[image]

Before change:

B b11, b12, ... , b1n;

B b21, b22, ... , b2m;

// the following is true

// (a1.isIdentical(b11.getA())) && ... &&
(a1.isIdentical(b1n.getA() )) &&

// (a2.isIdentical(b21.getA())) && ... &&
(a2.isIdentical(b2m.getA() ))

Change:

 _b1j.setA(b2k.getA());_

Expected result:

(a1.isIdentical(b11.getA())) &&

(a1.isIdentical(b12.getA())) &&

...

(a2.isIdentical(b1j.getA())) &&

...

(a1.isIdentical(b1n.getA())) &&

(a2.isIdentical(b21.getA())) &&

(a2.isIdentical(b22.getA())) &&

...

(a2.isIdentical(b2k.getA())) &&

...

(a2.isIdentical(b2m.getA()))



image:EBOpt-23.png[image]

===== Many-to-many Bidirectional Relationships



image:EBOpt-24.png[image]

Before change the following holds:

(a1.getB().contains(b1)) &&

(a1.getB().contains(b2)) &&

(a2.getB().contains(b1)) &&

(a2.getB().contains(b2)) &&

(a2.getB().contains(b3)) &&

(a3.getB().contains(b2)) &&

(a3.getB().contains(b3)) &&

(a3.getB().contains(b4)) &&

(a4.getB().contains(b3)) &&

(a4.getB().contains(b4)) &&

(a4.getB().contains(b5)) &&

(a5.getB().contains(b4)) &&

(a5.getB().contains(b5)) &&

(b1.getA().contains(a1)) &&

(b1.getA().contains(a2)) &&

(b2.getA().contains(a1)) &&

(b2.getA().contains(a2)) &&

(b2.getA().contains(a3)) &&

(b3.getA().contains(a2)) &&

(b3.getA().contains(a3)) &&

(b3.getA().contains(a4)) &&

(b4.getA().contains(a3)) &&

(b4.getA().contains(a4)) &&

(b4.getA().contains(a5)) &&

(b5.getA().contains(a4)) &&

(b5.getA().contains(a5)) &&



Change:

 _a1.setB(a3.getB());_

Expected result:

(a1.getB().contains(b2)) &&

(a1.getB().contains(b3)) &&

(a1.getB().contains(b4)) &&

(a3.getB().contains(b2)) &&

(a3.getB().contains(b3)) &&

(a3.getB().contains(b4)) &&

(b1.getA().contains(a2)) &&

(b2.getA().contains(a1)) &&

(b2.getA().contains(a2)) &&

(b2.getA().contains(a3)) &&

(b3.getA().contains(a1)) &&

(b3.getA().contains(a2)) &&

(b3.getA().contains(a3)) &&

(b3.getA().contains(a4)) &&

(b4.getA().contains(a1)) &&

(b4.getA().contains(a3)) &&

(b4.getA().contains(a4)) &&

(b4.getA().contains(a5))



image:EBOpt-25.png[image]

Change:

a1.getB().add(b3);

Expected result:

(a1.getB().contains(b1)) &&

(a1.getB().contains(b2)) &&

(a1.getB().contains(b3)) &&

(b3.getA().contains(a1)) &&

(b3.getA().contains(a2)) &&

(b3.getA().contains(a3)) &&

(b3.getA().contains(a4)) &&



image:EBOpt-26.png[image]

Change:

a2.getB().remove(b2);

Expected result:

(a2.getB().contains(b1)) &&

(a2.getB().contains(b3)) &&

(b2.getA().contains(a1)) &&

(b2.getA().contains(a3))



image:EBOpt-27.png[image]

===== Many-to-many Unidirectional Relationships



image:EBOpt-28.png[image]

Before change the following holds:

(a1.getB().contains(b1)) &&

(a1.getB().contains(b2)) &&

(a2.getB().contains(b1)) &&

(a2.getB().contains(b2)) &&

(a2.getB().contains(b3)) &&

(a3.getB().contains(b2)) &&

(a3.getB().contains(b3)) &&

(a3.getB().contains(b4)) &&

(a4.getB().contains(b3)) &&

(a4.getB().contains(b4)) &&

(a4.getB().contains(b5)) &&

(a5.getB().contains(b4)) &&

(a5.getB().contains(b5)) &&

Change:

 _a1.setB(a3.getB());_

Expected Result:

(a1.getB().contains(b2)) &&

(a1.getB().contains(b3)) &&

(a1.getB().contains(b4)) &&

(a3.getB().contains(b2)) &&

(a3.getB().contains(b3)) &&

(a3.getB().contains(b4)) &&



image:EBOpt-29.png[image]

Change:

a1.getB().add(b3);

Expected result:

(a1.getB().contains(b1)) &&

(a1.getB().contains(b2)) &&

(a1.getB().contains(b3))



image:EBOpt-30.png[image]

Change:

a2.getB().remove(b2);

Expected result:

(a2.getB().contains(b1)) &&

(a2.getB().contains(b3))



image:EBOpt-31.png[image]

==== Collections Managed by the Container

The collections
that are used in the representation of one-to-many and many-to-many
container-managed relationships are implemented and managed by the
container. The following semantics apply to these collections:

It is the responsibility of the container to
preserve the runtime identity of the collection objects used in
container-managed relationships.

There is no constructor available to the Bean
Provider for the container-managed collections.

If there are no related values for a given
container-managed relationship, the get accessor method for that
cmr-field returns an empty collection (and not _null_ ).

It is the responsibility of the container to
raise the _java.lang.IllegalArgumentException_
 if the Bean Provider attempts to assign
_null_ as the value of a collection-valued cmr-field by means of the set
accessor method.

It is the responsibility of the container to
ensure that when the _java.util.Collection_
API is used to manipulate the contents of container-managed relationship
fields, the argument to any Collection method defined with a single
Object parameter must be of the element type of the collection defined
for the target cmr-field. The argument for any collection-valued
parameter must be a _java.util.Collection_ (or _java.util.Set_ ), all of
whose elements are of the element type of the collection defined for the
target cmr-field. If an argument is not of the correct type for the
relationship, the container must throw the
_java.lang.IllegalArgumentException_ .

It is the responsibility of the container to
throw the _java.lang.IllegalStateException_
if an attempt is made to modify a container-managed collection
corresponding to a multivalued cmr-field using the
_java.util.Collection_ API outside of the transaction context in which
the collection object was initially materialized.

It is the responsibility of the container to
throw the _java.lang.IllegalStateException_ if an attempt is made to use
a _java.util.Iterator_  for a
container-managed collection in a transaction context other than that in
which the iterator was obtained.

==== Non-persistent State

The Bean Provider
may use instance variables in the entity
bean instance to maintain non-persistent state, e.g. a JMS connection.

The Bean Provider can use instance variables
to store values that depend on the persistent state of the entity bean
instance, although this use is not encouraged. The Bean Provider should
use the ejbLoad method to resynchronize the
values of any instance variables that depend on the entity bean’s
persistent state. In general, any non-persistent state that depends on
the persistent state of an entity bean should be recomputed during the
ejbLoad method.

The Bean Provider should exercise care in
passing the contents of instance variables as the arguments or results
of method invocations when local interfaces are used. In general, the
Bean Provider should avoid passing state that is maintained in instance
variables as the argument or result of a local method invocation.

==== The Relationship Between the Internal View and the Client View

In designing the
entity bean, the Bean Provider should keep in mind the following:

The classes that are exposed by the
remote interface are decoupled from the
persistence layer. Instances of these classes are passed to and from the
client by value.

The classes that are exposed by the
local interface of the bean may be tightly
coupled to the bean’s internal state. Instances of these classes are
passed to and from the client by reference and may therefore be modified
by the client. The Bean Provider should exercise care in determining
what is exposed through the local interface of the bean.

===== Restrictions on Remote Interfaces

The following restrictions apply to the
remote interface of an entity bean with container-managed persistence.

The Bean Provider must not expose the get and
set methods for container-managed relationship fields or the persistent
_Collection_ classes that are used in container-managed relationships
through the remote interface of the bean.

The Bean Provider must not expose local
interface types or local home interface types through the remote
interface or remote home interface of the bean.

The Bean Provider must not expose the
container-managed collection classes that are used for relationships
through the remote interface of the bean.

The Bean Provider must not expose timers or
timer handles through the remote interface of the bean.

Dependent value classes can be exposed in the
remote interface or remote home interface and can be included in the
client ejb-jar file.

The Bean Provider is free to expose get and
set methods that correspond to cmp-fields of the entity bean through the
bean’s remote interface.

==== Mapping Data to a Persistent Store

This
specification does not prescribe how the abstract persistence schema of
an entity bean should be mapped to a relational (or other) schema of a
persistent store, or define how such a mapping is described.

==== Example

link:Ejb.html#a861[See Relationship
Example] illustrates an _Order_ entity bean with relationships to line
items and customers, which are other entity beans within the same local
scope. _Product_ is indirectly related to _Order_ by means of the
relationship between _LineItem_ and _Product_ . Sample code for the
_OrderBean_ class follows the figure.

===



[[a861]]Relationship Example

image:EBOpt-32.png[image]





package com.acme.order;



// This example shows the implementation of
OrderBean, the

// entity bean class for the OrderEJB entity
bean. OrderEJB has

// container-managed relationships with the
entity beans

// CustomerEJB and LineItemEJB.

// This example illustrates the use of local
interfaces.



import java.util.Collection;

import java.util.Vector;

import java.util.Date;



import javax.naming.*;



public abstract class OrderBean implements
javax.ejb.EntityBean \{



 private javax.ejb.EntityContext context;



 // define status codes for processing



 static final int BACKORDER = 1;

 static final int SHIPPED = 2;

 static final int UNSHIPPED = 3;



 // get and set methods for the cmp fields



 public abstract int getOrderStatus();

 public abstract void setOrderStatus(int
orderStatus);



 public abstract boolean getCreditApproved();

 public abstract void
setCreditApproved(boolean creditapproved);



 public abstract Date getOrderDate();

 public abstract void setOrderDate(Date
orderDate);



 // get and set methods for the relationship
fields



 public abstract Collection getLineItems();

 public abstract void setLineItems(Collection
lineitems);



 public abstract Customer getCustomer();

 public abstract void setCustomer(Customer
customer);



 // business methods.





 // addLineItem:

 // This method is used to add a line item.

 // It creates the lineitem object and adds
it to the

 // persistent managed relationship.



 public void addLineItem(Product product,

 int quantity,

 Address address)

 throws InsufficientInfoException

 \{

 // create a new line item

 if (validAddress(address)) \{

 // Address is a legacy class. It is a
dependent value

 // class that is available both in the
client and in

 // the entity bean, and is serializable.

 // We will use the address as the value of a
cmp field

 // of lineItem.



 try \{

 Context ic = new InitialContext();

 LineItemLocalHome litemLocalHome =

 (LineItemLocalHome)ic.lookup("LineItemEJB");

 LineItem litem = litemLocalHome.create();



 litem.setProduct(product);

 litem.setQuantity(quantity);


litem.setTax(calculateTax(product.getPrice(),

 quantity,

 address));

 litem.setStatus(UNSHIPPED);

 // set the address for the line item to be
shipped

 litem.setAddress(address);

 // The lineItem entity bean uses a dependent
value

 // class to represent the dates for the
order status.

 // This class holds shipment date, expected
shipment

 // date, credit approval date, and inventory

 // dates which are internal to the order
fullfillment

 // process. Not all this information will be
available

 // to the client.



 Dates dates = new Dates();

 litem.setDates(dates);

 getLineItems().add(litem);

 } catch (Exception someexception) \{}

 } else \{

 throw new InsufficientInfoException();

 }

 }





 // getOrderLineItems:

 // This method makes a view of the lineitems
that are in this

 // order available in the client. It makes
only the relevant

 // information visible to the client and
hides the internal

 // details of the representation of the
lineitem

 public Collection getOrderLineItems() \{

 Vector clientlineitems = new Vector();

 Collection lineitems = getLineItems();

 java.util.Iterator iterator =
lineitems.iterator();

 // ClientLineItem is a value class that is
used in

 // the client view.

 // The entity Bean Provider abstracts from
the persistent

 // representation of the line item to
construct the client

 // view.

 ClientLineItem clitem;

 while (iterator.hasNext()) \{

 LineItem litem = (LineItem)iterator.next();

 clitem = new ClientLineItem();

 // only the name of the product is available
in the

 // client view


clitem.setProductName(litem.getProduct().getName());

 clitem.setQuantity(litem.getQuantity());

 // the client view gets a specific
descriptive message

 // depending on the line item status.

 clitem.setCurrentStatus(

 statusCodeToString(litem.getStatus()));

 // address is not copied to the client view.

 // as this class includes other information
with

 // respect to the order handing that should
not be

 // available to the client. Only the
relevant info

 // is copied.

 int lineitemStatus = litem.getStatus();

 if ( lineitemStatus == BACKORDER) \{

 clitem.setShipDate(

 litem.getDates().getExpectedShipDate());

 } else if (lineitemStatus == SHIPPED) \{

 clitem.setShipDate(

 litem.getDates().getShippedDate());

 }

 //add the new line item

 clientlineitems.add(clitem);

 }

 // return the value objects to the client

 return clientlineitems;

 }



 // other methods internal to the entity bean
class

 ...



 // other javax.ejb.EntityBean methods

 ...

}


[[a1013]]
==== The Bean Provider’s View of the Deployment Descriptor

The persistent fields (cmp-fields) and
relationships (cmr-fields) of an entity bean must be declared in the
deployment descriptor.

The deployment descriptor provides the
following information about the abstract persistence schemas of entity
beans and their container-managed
relationships:

An _ejb-name_ element for each entity bean.
The _ejb-name_ must be a valid Java identifier and must be unique within
the _ejb-name_ elements of the ejb-jar file.

An _abstract-schema-name_ element for each
entity bean. The _abstract-schema-name_ must be a valid Java identifier
and must be unique within the _abstract-schema-name_ elements of the
ejb-jar file. The _abstract-schema-name_ element is used in the
specification of EJB QL queries.

{empty}A set of _ejb-relation_ elements, each
of which contains a pair of _ejb-relationship-role_ elements to describe
the two roles in the relationship.link:#a3369[5]

Each _ejb-relationship-role_ element
describes a relationship role: its name, its multiplicity within a
relation, and its navigability. It specifies the name of the _cmr-field_
that is used from the perspective of the relationship participant. The
_cmr-field-type_ element must be specified if the type of the cmr-field
is _java.util.Collection_ or _java.util.Set_ . Each relationship role
refers to an entity bean by means of an ejb-name element contained in
the _relationship-role-source_ element.

The following example shows a deployment
descriptor segment that defines the abstract persistence schema for a
set of related entity beans. The deployment descriptor elements for
container-managed persistence and relationships are described further in
Chapter link:Ejb.html#a3273[See Deployment Descriptor].

<ejb-jar>



...



<enterprise-beans>

...

</enterprise-beans>



<relationships>



<!--

ONE-TO-MANY: Order LineItem

-->



 <ejb-relation>


<ejb-relation-name>Order-LineItem</ejb-relation-name>

 <ejb-relationship-role>

 <ejb-relationship-role-name>

 order-has-lineitems

 </ejb-relationship-role-name>

 <multiplicity>One</multiplicity>

 <relationship-role-source>

 <ejb-name>OrderEJB</ejb-name>

 </relationship-role-source>

 <cmr-field>

 <cmr-field-name>lineItems</cmr-field-name>

 <cmr-field-type>java.util.Collection

 </cmr-field-type>

 </cmr-field>

 </ejb-relationship-role>



 <ejb-relationship-role>


<ejb-relationship-role-name>lineitem-belongsto-order

 </ejb-relationship-role-name>

 <multiplicity>Many</multiplicity>

 <cascade-delete/>

 <relationship-role-source>

 <ejb-name>LineItemEJB</ejb-name>

 </relationship-role-source>

 <cmr-field>

 <cmr-field-name>order</cmr-field-name>

 </cmr-field>

 </ejb-relationship-role>

 </ejb-relation>



<!--

ONE-TO-MANY unidirectional relationship:

Product is not aware of its relationship with
LineItem

-->



 <ejb-relation>


<ejb-relation-name>Product-LineItem</ejb-relation-name>



 <ejb-relationship-role>

 <ejb-relationship-role-name>

 product-has-lineitems

 </ejb-relationship-role-name>

 <multiplicity>One</multiplicity>

 <relationship-role-source>

 <ejb-name>ProductEJB</ejb-name>

 </relationship-role-source>

 <!-- since Product does not know about
LineItem

 there is no cmr field in Product for
accessing

 Lineitem

 -->

 </ejb-relationship-role>



 <ejb-relationship-role>

 <ejb-relationship-role-name>

 lineitem-for-product

 </ejb-relationship-role-name>

 <multiplicity>Many</multiplicity>

 <relationship-role-source>

 <ejb-name>LineItemEJB</ejb-name>

 </relationship-role-source>

 <cmr-field>

 <cmr-field-name>product</cmr-field-name>

 </cmr-field>

 </ejb-relationship-role>



 </ejb-relation>





<!--

ONE-TO-MANY: Order Customer:

-->



 <ejb-relation>


<ejb-relation-name>Order-Customer</ejb-relation-name>



 <ejb-relationship-role>

 <ejb-relationship-role-name>

 customer-has-orders

 </ejb-relationship-role-name>

 <multiplicity>One</multiplicity>

 <relationship-role-source>

 <ejb-name>CustomerEJB</ejb-name>

 </relationship-role-source>

 <cmr-field>

 <cmr-field-name>orders</cmr-field-name>

 <cmr-field-type>java.util.Collection

 </cmr-field-type>

 </cmr-field>

 </ejb-relationship-role>



 <ejb-relationship-role>

 <ejb-relationship-role-name>

 order-belongsto-customer

 </ejb-relationship-role-name>

 <multiplicity>Many</multiplicity>

 <relationship-role-source>

 <ejb-name>OrderEJB</ejb-name>

 </relationship-role-source>

 <cmr-field>

 <cmr-field-name>customer</cmr-field-name>

 </cmr-field>

 </ejb-relationship-role>



 </ejb-relation>







</relationships>



...



</ejb-jar>

=== The Entity Bean Component Contract



This section specifies the container-managed
persistence contract between an entity bean and its container.

==== Runtime Execution Model of Entity Beans

This subsection
describes the runtime model and the classes
used in the description of the contract between an entity bean and its
container. link:Ejb.html#a1155[See Overview of the Entity Bean
Runtime Execution Model] shows an overview of the runtime model. The
client of an entity bean may be a local client or it may be a remote
client.

===



[[a1155]]Overview of the Entity Bean Runtime Execution Model

image:EBOpt-33.png[image]

An enterprise bean is an object whose class
is provided by the Bean Provider. The class of an entity bean with
container-managed persistence is abstract. The concrete bean class is
generated by the Container Provider’s tools at deployment time. The
container is also responsible for providing the implementation of the
_java.util.Collection_ classes that are used in maintaining the
container-managed relationships of the entity bean.

An entity _EJBObject_
 or
EJBLocalObject is an object whose class was
generated at deployment time by the Container Provider’s tools. A client
never references an entity bean instance directly—a client always
references an entity EJBObject or EJBLocalObject whose class is
generated by the Container Provider’s tools. The entity EJBObject class
implements an entity bean’s remote interface. The entity EJBLocalObject
class implements an entity bean’s local interface. A related entity bean
never references another entity bean instance directly—a related entity
bean, like any other local client of an entity bean, always references
an entity EJBLocalObject whose class is generated by the Container
Provider’s tools.

An entity _EJBHome_
 or EJBLocalHome
object provides life cycle operations
(create, find, remove) for its entity objects as well as home business
methods, which are business methods that are not specific to an entity
bean instance. The class for the entity EJBHome or EJBLocalHome object
is generated by the Container Provider’s tools at deployment time. The
entity EJBHome or EJBLocalHome object implements the entity bean’s
remote or local home interface that was defined by the Bean Provider.

==== Container Responsibilities

The following are the container
responsibilities for the management of persistent state.

===== Container-Managed Fields

An entity bean with container-managed
persistence relies on the container to perform
persistent data access on behalf of the
entity bean instances. The container transfers data between an entity
bean instance and the underlying resource manager. The container also
implements the creation, removal, and lookup of the entity object in the
underlying database.

The container
transfers data between the entity bean and the underlying data source as
a result of the execution of the entity bean’s methods. Because of the
requirement that all data access occur through the
accessor methods, the container can
implement both eager and
lazy loading and storing schemes.

The container is responsible for implementing
the entity bean class by providing the implementation of the get and set
accessor methods for its abstract persistence schema. The container is
allowed to use Java serialization to store the container-managed
persistent fields (cmp-fields).

The container must also manage the mapping
between primary keys and EJBLocalObjects or
EJBObjects. If both a remote and a local interface are specified for the
entity bean, the container must manage the mapping between EJBObjects
and EJBLocalObjects.

Because the container is free to optimize the
delivery of persistent data to the bean instance (for example, by the
use of lazy loading strategies), the contents of the entity bean
instance and the contents of container-managed collections may not be
fully materialized.

===== Container-Managed Relationships

The container
maintains the relationships among entity beans.

It is the responsibility of the container to
maintain the referential integrity of the
container-managed relationships, as described in
link:Ejb.html#a496[See Semantics of Assignment for
Relationships], in accordance with the semantics of the relationship
type as specified in the deployment descriptor. For example, if an
entity bean is added to a collection corresponding to the
container-managed relationship field of another entity bean, the
container-managed relationship field of the first entity bean must also
be updated by the container in the same transaction context.

It is the responsibility of the container to
throw the _java.lang.IllegalArgumentException_
 when the argument to a set method in a
relationship is an instance of the wrong relationship type or a
collection containing instances of the wrong type, or when an argument
to a method of the _java.util.Collection_
API used to manipulate a collection-valued container-managed
relationship field is an instance of the wrong type or a collection that
contains instances of the wrong type (see Section
link:Ejb.html#a496[See Semantics of Assignment for
Relationships]).

It is the responsibility of the container to
throw the _java.lang.IllegalStateException_
when a method of the _java.util.Collection_ API is used to access a
collection-valued cmr-field within a transaction context other than the
transaction context in which the cmr-field was initially materialized.
For example, if the container-managed collection is returned as the
result of a local interface method with transaction attribute
_RequiresNew_ , and the client attempts to access the collection, the
container must throw the _IllegalStateException_ .

It is the responsibility of the container to
throw the _java.lang.IllegalStateException_ when a _java.util.Iterator_
 is used to access a collection-valued
cmr-field within a transaction context other than the transaction
context in which the iterator was initially obtained.

=== Instance Life Cycle Contract Between the Bean and the Container



This section
describes the part of the component contract between the entity bean and
the container that relates to the management of the entity bean
instance’s life cycle.

==== Instance Life Cycle

===



[[a1191]]Life Cycle of an Entity Bean Instance.

image:EBOpt-34.png[image]

An entity bean
instance is in one of the following three states:

It does not exist.

Pooled state. An instance in the pooled state
is not associated with any particular entity object identity.

Ready state. An instance in the ready state
is assigned an entity object identity.

The following
steps describe the life cycle of an entity bean instance:

An entity bean instance’s life starts when
the container creates the instance using newInstance. The container then
invokes the setEntityContext method to pass the instance a reference to
the EntityContext interface. The EntityContext interface allows the
instance to invoke services provided by the container and to obtain the
information about the caller of a client-invoked method.

The instance enters the pool of available
instances. Each entity bean has its own pool. While the instance is in
the available pool, the instance is not associated with any particular
entity object identity. All instances in the pool are considered
equivalent, and therefore any instance can be assigned by the container
to any entity object identity at the transition to the ready state.
While the instance is in the pooled state, the container may use the
instance to execute any of the entity bean’s finder methods (shown as
_ejbFind<METHOD>_ in the diagram) or any of the entity bean’s home
methods (shown ejbHome<METHOD> in the diagram). The instance does _not_
move to the ready state during the execution of a finder or a home
method. An _ejbSelect<METHOD>_ method may be called by an entity bean’s
home method while the instance is in the pooled state.

An instance transitions from the
pooled state to the
ready state when the container selects that
instance to service a client call to an entity object or an _ejbTimeout_
method. There are two possible transitions from the pooled to the ready
state: through the _ejbCreate<METHOD>_ and _ejbPostCreate<METHOD>_
methods, or through the _ejbActivate_ method. The container invokes the
_ejbCreate<METHOD>_ and _ejbPostCreate<METHOD>_ methods when the
instance is assigned to an entity object during entity object creation
(i.e., when the client invokes a create method on the entity bean’s home
object). The container invokes the _ejbActivate_ method on an instance
when an instance needs to be activated to service an invocation on an
existing entity object—this occurs because there is no suitable instance
in the ready state to service the client’s call or the _ejbTimeout_
method.

When an entity bean instance is in the ready
state, the instance is associated with a specific entity object
identity. While the instance is in the ready state, the container can
synchronize the state of the instance with the state of the entity in
the underlying data source whenever it determines the need to, in the
process invoking the _ejbLoad_ and _ejbStore_ methods zero or more
times. A business method can be invoked on the instance zero or more
times. The _ejbTimeout_ method can be invoked on the instance zero or
more times. Invocations of the _ejbLoad_ and _ejbStore_ methods can be
arbitrarily mixed with invocations of business methods and _ejbTimeout_
method invocations. An _ejbSelect<METHOD>_ method can be called by a
business method (or _ejbLoad_ or _ejbStore_ method or _ejbTimeout_
method ) while the instance is in the ready state.

The container can choose to
passivate an entity bean instance within a
transaction. To passivate an instance, the container first invokes the
ejbStore method to allow the instance to prepare itself for the
synchronization of the database state with the instance’s state, and
then the container invokes the ejbPassivate
method to return the instance to the pooled state.

Eventually, the container will transition the
instance to the pooled state. There are
three possible transitions from the ready to the pooled state: through
the _ejbPassivate_ method, through the _ejbRemove_ method, and because
of a transaction rollback for _ejbCreate_ , _ejbPostCreate_ , or
_ejbRemove_ (not shown in link:Ejb.html#a1191[See Life Cycle of
an Entity Bean Instance.]). The container invokes the _ejbPassivate_
method when the container wants to disassociate the instance from the
entity object identity without removing the entity object. The container
invokes the _ejbRemove_ method when the container is removing the entity
object (i.e., when the client invoked the _remove_ method on the entity
object’s component interface or a _remove_ method on the entity bean’s
home interface). If _ejbCreate_ , _ejbPostCreate_ , or _ejbRemove_ is
called and the transaction rolls back, the container will transition the
bean instance to the pooled state.

When the instance is put back into the pool,
it is no longer associated with an entity object identity. The container
can assign the instance to any entity object within the same entity bean
home.

The container can remove an instance in the
pool by calling the _unsetEntityContext_
method on the instance.

Notes:

The EntityContext
interface passed by the container to the instance in the
setEntityContext method is an interface, not a class that contains
static information. For example, the result of the
EntityContext.getPrimaryKey method might be different each time an
instance moves from the pooled state to the ready state, and the result
of the getCallerPrincipal and isCallerInRole methods may be different in
each business method.

A RuntimeException thrown from any method of
an entity bean class (including the business methods and the callbacks
invoked by the container) results in the transition to the “does not
exist” state. The container must not invoke any method on the instance
after a RuntimeException has been caught. From the caller’s perspective,
the corresponding entity object continues to exist. The client can
continue accessing the entity object through its component interface
because the container can use a different entity bean instance to
delegate the client’s requests. Exception handling is described further
in Chapter link:Ejb.html#a3210[See Exception Handling].

The container is not required to maintain a
pool of instances in the pooled state. The
pooling approach is an example of a possible implementation, but it is
not the required implementation. Whether the container uses a pool or
not has no bearing on the entity bean coding
style.

==== Bean Provider’s Entity Bean Instance’s View

The following describes the entity bean
instance’s view of the contract as seen by the Bean Provider:

The entity Bean
Provider is responsible for implementing the following methods in the
abstract entity bean class:

A public
constructor that takes no arguments.

 _public void setEntityContext(EntityContext
ic)_ ;

A container uses
this method to pass a reference to the EntityContext interface to the
entity bean instance. If the entity bean instance needs to use the
EntityContext interface during its lifetime, it must remember the
EntityContext interface in an instance variable.

This method executes with an unspecified
transaction context (Refer to EJB Core Contracts and Requirements
document link:Ejb.html#a3339[See EJB 3.2 Core Contracts and
Requirements. http://jcp.org/en/jsr/detail?id=345] Subsection “Handling
of Methods that Run with an unspecified transaction context” for how the
container executes methods with an unspecified transaction context). An
identity of an entity object is not available during this method. The
entity bean must not attempt to access its persistent state and
relationships using the accessor methods during this method.

The instance can take advantage of the
setEntityContext() method to allocate any resources that are to be held
by the instance for its lifetime. Such resources cannot be specific to
an entity object identity because the instance might be reused during
its lifetime to serve multiple entity object identities.

 _public void unsetEntityContext();_

A container
invokes this method before terminating the life of the instance.

This method executes with an unspecified
transaction context. An identity of an entity object is not available
during this method. The entity bean must not attempt to access its
persistent state and relationships using the accessor methods during
this method.

The instance can take advantage of the
_unsetEntityContext_ method to free any resources that are held by the
instance. (These resources typically had been allocated by the
setEntityContext method.)

 _public PrimaryKeyClass
ejbCreate<METHOD>(...)_ ;

There are
zerolink:#a3370[6] or more ejbCreate<METHOD> methods, whose
signatures match the signatures of the create<METHOD> methods of the
entity bean’s home interface. The container invokes an
_ejbCreate<METHOD>_ method on an entity bean instance when a client
invokes a matching create<METHOD> method on the entity bean’s home
interface.

The entity Bean Provider’s responsibility is
to initialize the instance in the ejbCreate<METHOD> methods from the
input arguments, using the get and set accessor methods, such that when
the _ejbCreate<METHOD>_ method returns, the persistent representation of
the instance can be created. The entity Bean Provider is guaranteed that
the values that will be initially returned by the instance’s get methods
for container-managed fields will be the Java language defaults (e.g. 0
for integer, null for pointers), except for collection-valued
cmr-fields, which will have the empty collection (or set) as their
value. The entity Bean Provider must not attempt to modify the values of
cmr-fields in an _ejbCreate<METHOD>_ method. This should be done in the
_ejbPostCreate<METHOD>_ method instead.

{empty}The entity object created by the
_ejbCreate<METHOD>_ method must have a unique primary key. This means
that the primary key must be different from the primary keys of all the
existing entity objects within the same home. However, it is legal to
reuse the primary key of a previously removed entity object. The
implementation of the Bean Provider’s _ejbCreate<METHOD>_ methods should
be coded to return a null.link:#a3371[7]

An _ejbCreate<METHOD>_ method executes in the
transaction context determined by the transaction attribute of the
matching create<METHOD> method. The database insert operations are
performed by the container within the same transaction context after the
Bean Provider’s ejbCreate<METHOD> method completes.

 _public void ejbPostCreate<METHOD>(...);_

For each
ejbCreate<METHOD> method, there is a matching ejbPostCreate<METHOD>
method that has the same input parameters but whose return type is
_void_ . The container invokes the matching ejbPostCreate<METHOD> method
on an instance after it invokes the ejbCreate<METHOD> method with the
same arguments. The instance can discover the primary key by calling
_getPrimaryKey_ on its entity context object.

The entity object identity is available
during the ejbPostCreate<METHOD> method. The instance may, for example,
obtain the component interface of the associated entity object and pass
it to another enterprise bean as a method argument.

The entity Bean Provider may use the
_ejbPostCreate<METHOD>_ to set the values of cmr-fields to complete the
initialization of the entity bean instance.

An _ejbPostCreate<METHOD>_ method executes in
the same transaction context as the previous ejbCreate<METHOD> method.

 _public void ejbActivate();_

The container
invokes this method on the instance when the container picks the
instance from the pool and assigns it to a specific entity object
identity. The ejbActivate method gives the entity bean instance the
chance to acquire additional resources that it needs while it is in the
ready state.

This method executes with an unspecified
transaction context. The entity bean must not attempt to access its
persistent state or relationships using the accessor methods during this
method.

The instance can obtain the identity of the
entity object via the getPrimaryKey, _getEJBLocalObject_ , or
getEJBObject method on the entity context. The instance can rely on the
fact that the primary key and entity object identity will remain
associated with the instance until the completion of ejbPassivate or
ejbRemove.

 _public void ejbPassivate()_ ; +
The container invokes this method on an
instance when the container decides to disassociate the instance from an
entity object identity, and to put the instance back into the pool of
available instances. The _ejbPassivate_ method gives the instance the
chance to release any resources that should not be held while the
instance is in the pool. (These resources typically had been allocated
during the _ejbActivate_ method.)

This method executes with an unspecified
transaction context. The entity bean must not attempt to access its
persistent state or relationships using the accessor methods during this
method.

The instance can still obtain the identity of
the entity object via the getPrimaryKey, _getEJBLocalObject_ , or
getEJBObject method of the EntityContext interface.

 _public void ejbRemove()_ ;

The container
invokes the ejbRemove method on an entity bean instance in response to a
client-invoked remove operation on the entity bean’s home or component
interface or as the result of a cascade-delete operation. The instance
is in the ready state when ejbRemove is invoked and it will be entered
into the pool when the method completes.

The entity Bean Provider can use the
ejbRemove method to implement any actions that must be done before the
entity object’s persistent representation is removed.

The container synchronizes the instance’s
state before it invokes the ejbRemove method. This means that the state
of the instance at the beginning of the ejbRemove method is the same as
it would be at the beginning of a business method.

This method and the database delete
operation(s) execute in the transaction context determined by the
transaction attribute of the remove method that triggered the
_ejbRemove_ method. The instance can still obtain the identity of the
entity object via the getPrimaryKey, getEJBLocalObject, or getEJBObject
method of the EntityContext interface.

After the entity Bean Provider’s ejbRemove
returns, and in the same transaction context, the container removes the
entity bean from all relationships in which it participates before
removing the entity object’s persistent representation.

Since the instance will be entered into the
pool, the state of the instance at the end of this method must be
equivalent to the state of a passivated instance. This means that the
instance must release any resource that it would normally release in the
ejbPassivate method.

 _public void ejbLoad()_ ;

When the
container needs to synchronize the state of an enterprise bean instance
with the entity object’s persistent state, the container calls the
_ejbLoad_ method.

The entity Bean Provider can assume that the
instance’s persistent state has been loaded just before the ejbLoad
method is invoked. It is the responsibility of the Bean Provider to use
the _ejbLoad_ method to recompute or initialize the values of any
instance variables that depend on the entity bean’s persistent state. In
general, any transient state that depends on the persistent state of an
entity bean should be recalculated using the ejbLoad method. The entity
bean can use the ejbLoad method, for instance, to perform some
computation on the values returned by the accessor methods (for example,
uncompressing text fields).

This method executes in the transaction
context determined by the transaction attribute of the business method
or _ejbTimeout_ method that triggered the ejbLoad method.

 _public void ejbStore();_

When the
container needs to synchronize the state of the entity object’s
persistent state with the state of the enterprise bean instance, the
container first calls the ejbStore method on the instance.

The entity Bean Provider should use the
ejbStore method to update the instance using the accessor methods before
its persistent state is synchronized. For example, the ejbStore method
may perform compression of text before the text is stored in the
database.

The Bean Provider can assume that after the
_ejbStore_ method returns, the persistent state of the instance is
synchronized.

This method executes in the same transaction
context as the previous ejbLoad or ejbCreate method invoked on the
instance. All business methods or the _ejbTimeout_ method invoked
between the previous ejbLoad or ejbCreate _<METHOD>_ method and this
ejbStore method are also invoked in the same transaction context.

public <primary key type or collection>
ejbFind<METHOD>(...);

The Bean Provider
of an entity bean with container-managed persistence does not write the
finder (ejbFind<METHOD>) methods.

The finder methods are generated at the
entity bean deployment time using the Container Provider’s tools. The
syntax for the Bean Provider’s specification of finder methods is
described in the link:Ejb.html#a1840[See EJB QL: EJB 2.1 Query
Language for Container-Managed Persistence Query Methods].

public <type> ejbHome<METHOD>(...);

The container
invokes this method on the instance when the container selects the
instance to execute a matching client-invoked <METHOD> home method. The
instance is in the pooled state (i.e., it is not assigned to any
particular entity object identity) when the container selects the
instance to execute the ejbHome<METHOD> method on it, and it is returned
to the pooled state when the execution of the ejbHome<METHOD> method
completes.

The ejbHome<METHOD> method executes in the
transaction context determined by the transaction attribute of the
matching <METHOD> home method, as described in EJB Core Contracts and
Requirements document link:Ejb.html#a3339[See EJB 3.2 Core
Contracts and Requirements. http://jcp.org/en/jsr/detail?id=345]
Subsection “Container-Managed Transaction Demarcation for Business
Methods”.

The entity Bean Provider provides the
implementation of the ejbHome<METHOD> method. The entity bean must not
attempt to access its persistent state or relationships using the
accessor methods during this method because a home method is not
specific to a particular bean instance.

public abstract <type> _e_
jbSelect<METHOD>(...);

The Bean Provider
may provide zero or more select methods. A select method is a query
method that is not directly exposed to the client in the home or
component interface. The Bean Provider typically calls a select method
within a business method.

The Bean Provider defines the select methods
as _abstract_ methods.

The select methods are generated at the
entity bean deployment time using the Container Provider’s tools.

The syntax for the specification of select
methods is described in link:Ejb.html#a1840[See EJB QL: EJB 2.1
Query Language for Container-Managed Persistence Query Methods].

The ejbSelect<METHOD> method executes in the
transaction context determined by the transaction attribute of the
invoking business method.

 _public void ejbTimeout(...);_

The container invokes the _ejbTimeout_ method
on an instance when a timer for the instance has expired. The
_ejbTimeout_ method notifies the instance of the time-based event and
allows the instance to execute the business logic to handle it.

The _ejbTimeout_ method executes in the
transaction context determined by its transaction attribute.

[[a1279]]
==== Container’s View

This subsection
describes the container’s view of the state management contract. The
container must call the following methods:

 _public void setEntityContext(ec)_ ;

The container
invokes this method to pass a reference to the EntityContext interface
to the entity bean instance. The container must invoke this method after
it creates the instance, and before it puts the instance into the pool
of available instances.

The container invokes this method with an
unspecified transaction context. At this point, the EntityContext is not
associated with any entity object identity.

 _public void unsetEntityContext()_ ;

The container
invokes this method when the container wants to reduce the number of
instances in the pool. After this method completes, the container must
not reuse this instance.

The container invokes this method with an
unspecified transaction context.

 _public_ _PrimaryKeyClass_
_ejbCreate<METHOD>(...)_ ; +
_public void ejbPostCreate<METHOD>(...)_ ;

The container
invokes these two methods during the creation of an entity object as a
result of a client invoking a create<METHOD> method on the entity bean’s
home interface.

The container invokes the ejbCreate<METHOD>
method whose signature matches the create<METHOD> method invoked by the
client.

Prior to invoking the ejbCreate<METHOD>
method provided by the Bean Provider, the container must ensure that the
values that will be initially returned by the instance’s get methods for
container-managed fields will be the Java language defaults (e.g. 0 for
integer, null for pointers), except for collection-valued cmr-fields,
which must have the empty collection (or set) as their value.

The container is responsible for calling the
_ejbCreate<METHOD>_ method, for obtaining the primary key fields of the
newly created entity object persistent representation, and for creating
an entity EJBObject reference and/or EJBLocalObject reference for the
newly created entity object. The container must establish the primary
key before it invokes the ejbPostCreate<METHOD> method.

The entity object created by the
_ejbCreate<METHOD>_ method must have a unique primary key. This means
that the primary key must be different from the primary keys of all the
existing entity objects within the same home. However, it is legal to
reuse the primary key of a previously removed entity object. The
container may, but is not required to, throw the _DuplicateKeyException_
on the Bean Provider’s attempt to create an entity object with a
duplicate primary keylink:#a3372[8].

The container may create the representation
of the entity in the database immediately, or it can defer it to a later
time (for example to the time after the matching ejbPostCreate<METHOD>
has been called, or to the end of the transaction), depending on the
caching strategy that it uses.

The container then invokes the matching
ejbPostCreate<METHOD> method with the same arguments on the instance to
allow the instance to fully initialize itself. The instance can discover
the primary key by calling the getPrimaryKey method on its entity
context object.

Finally, the container returns the entity
object’s remote interface (i.e., a reference to the entity EJBObject) to
the client if the client is a remote client or the entity object’s local
interface (i.e., a reference to the entity EJBLocalObject) if the client
is a local client.

The container must invoke the ejbCreate
_<METHOD>_ and ejbPostCreate _<METHOD>_ methods and create the
representation of the persistent instance in the database in the
transaction context determined by the transaction attribute of the
matching create<METHOD> method, as described in EJB Core Contracts and
Requirements document link:Ejb.html#a3339[See EJB 3.2 Core
Contracts and Requirements. http://jcp.org/en/jsr/detail?id=345]
Subsection “Container-Managed Transaction Demarcation for Business
Methods”.

 _public void ejbActivate()_ ;

The container
invokes this method on an entity bean instance at activation time (i.e.,
when the instance is taken from the pool and assigned to an entity
object identity). The container must ensure that the primary key of the
associated entity object is available to the instance if the instance
invokes the getPrimaryKey, _getEJBLocalObject_ , or getEJBObject method
on its EntityContext interface.

The container invokes this method with an
unspecified transaction context.

Note that instance is not yet ready for the
delivery of a business method. The container must still invoke the
ejbLoad method prior to a business method.

 _public void ejbPassivate()_ ;

The container
invokes this method on an entity bean instance at passivation time
(i.e., when the instance is being disassociated from an entity object
identity and moved into the pool). The container must ensure that the
identity of the associated entity object is still available to the
instance if the instance invokes the getPrimaryKey, _getEJBLocalObject_
, or getEJBObject method on its entity context.

The container invokes this method with an
unspecified transaction context.

Note that if the instance state has been
updated by a transaction, the container must first invoke the ejbStore
method on the instance before it invokes ejbPassivate on it.

 _public void ejbRemove();_

The container
invokes the ejbRemove method in response to a client-invoked remove
operation on the entity bean’s home or component interface or as the
result of a cascade-delete operation. The instance is in the ready state
when _ejbRemove_ is invoked and it will be entered into the pool when
the method completes.

The container synchronizes the instance’s
state before it invokes the ejbRemove method. This means that the
persistent state of the instance at the beginning of the ejbRemove
method is the same as it would be at the beginning of a business method
(i.e., if the instance is not already synchronized from the state in the
database, the container must invoke _ejbLoad_ before it invokes
_ejbRemove_ ).

The container must ensure that the identity
of the associated entity object is still available to the instance in
the _ejbRemove_ method (i.e., the instance can invoke the getPrimaryKey,
_getEJBLocalObject_ , or getEJBObject method on its EntityContext in the
_ejbRemove_ method).

After the entity Bean Provider’s ejbRemove
method returns, and in the same transaction context, the container
removes the entity bean instance from all relationships in which it
participates and then removes the entity object’s persistent
representation.

The container may delete the representation
of the entity in the database immediately, or it can defer it to a later
time (for example to the end of the transaction), depending on the
caching strategy that it uses.

The container must ensure that the ejbRemove
method and database delete operations are performed in the transaction
context determined by the transaction attribute of the invoked remove
method, as described in EJB Core Contracts and Requirements document
link:Ejb.html#a3339[See EJB 3.2 Core Contracts and Requirements.
http://jcp.org/en/jsr/detail?id=345] Subsection “Container-Managed
Transaction Demarcation for Business Methods”.

 _public void ejbLoad()_ ;

When the
container needs to synchronize the state of an enterprise bean instance
with the entity object’s state in the database, the container calls the
_ejbLoad_ method. Depending on its caching strategy, the container may
first read the entity object’s state from the database, before invoking
the _ejbLoad_ method, or it may use a lazy loading strategy in making
this state visible to the instance.

The exact times that the container invokes
_ejbLoad_ depend on the configuration of the component and the
container, and are not defined by the EJB architecture. Typically, the
container will call _ejbLoad_ before the first business method within a
transaction or before invoking the _ejbTimeout_ method on an instance.

The container must invoke this method in the
transaction context determined by the transaction attribute of the
business method or _ejbTimeout_ method that triggered the ejbLoad
method.

 _public void ejbStore()_ ;

When the
container needs to synchronize the state of the entity object in the
database with the state of the enterprise bean instance, the container
calls the ejbStore method on the instance. This synchronization always
happens at the end of a transaction, unless the bean is specified as
read-only (see section link:Ejb.html#a1342[See Read-only Entity
Beans]). However, the container may also invoke this method when it
passivates the instance in the middle of a transaction, or when it needs
to transfer the most recent state of the entity object to another
instance for the same entity object in the same transaction.

The container must invoke this method in the
same transaction context as the previous ejbLoad, ejbCreate _<METHOD>_ ,
or _ejbTimeout_ method invoked on the instance. All business methods or
the _ejbTimeout_ method invoked between the previous ejbLoad or
ejbCreate _<METHOD>_ method and this ejbStore method are also invoked in
the same transaction context.

After the _ejbStore_ method returns, the
container may store the persistent state of the instance to the
database, depending on its caching strategy. If the container uses a
lazy storing caching strategy, it is the container’s responsibility to
write the representation of the persistent object to the database in the
same transaction context as that of the _ejbStore_ method.

public <primary key type or collection>
ejbFind<METHOD>(...);

The implementation of the _ejbFind<METHOD>_
 method is supplied by the container.

The container invokes the ejbFind<METHOD>
method on an instance when a client invokes a matching find<METHOD>
method on the entity bean’s home interface. The container must pick an
instance that is in the pooled state (i.e., the instance is not
associated with any entity object identity) for the execution of the
ejbFind<METHOD> method. If there is no instance in the pooled state, the
container creates one and calls the setEntityContext method on the
instance before dispatching the finder method.

The container must invoke the ejbFind<METHOD>
method in the transaction context determined by the transaction
attribute of the matching find method, as described in EJB Core
Contracts and Requirements document link:Ejb.html#a3339[See EJB
3.2 Core Contracts and Requirements.
http://jcp.org/en/jsr/detail?id=345] Subsection “Container-Managed
Transaction Demarcation for Business Methods”.

The container is responsible for ensuring
that updates to the states of all entity beans in the same transaction
context as the _ejbFind<METHOD>_ method and whose abstract schema types
are accessed in the method’s EJB QL query are visible in the results of
the _ejbFind<METHOD>_ method. Before invoking the _ejbFind<METHOD>_
method, the container must first synchronize the state of those entity
bean instances by invoking the _ejbStore_ method on them. This
requirement does not apply to the _ejbFindByPrimaryKey_ method. The
results of the _ejbFindByPrimaryKey_ method, however, must reflect the
entities that have been created or removed within the same transaction
context.

After the ejbFind<METHOD> method completes,
the instance remains in the pooled state. The container may, but is not
required to, immediately activate the objects that were located by the
finder using the transition through the ejbActivate method.

If the ejbFind<METHOD> method is declared to
return a single primary key, the container creates an entity EJBObject
(EJBLocalObject) reference for the primary key and returns it to the
client (local client). If the ejbFind<METHOD> method is declared to
return a collection of primary keys, the container creates a collection
of entity EJBObject (EJBLocalObject) references for the primary keys
returned from the ejbFind<METHOD> method, and returns the collection to
the client (local client).

The implementations of the finder methods are
generated at the entity bean deployment time using the Container
Provider’s tools.

public __ <type> __ ejbSelect<METHOD>(...);

A select method
is a query method that is not directly exposed to the client in the home
or component interface. The Bean Provider typically calls a select
method within a business method or home method.

A select method executes in the transaction
context determined by the transaction attribute of the invoking business
method.

The container is responsible for ensuring
that all updates to the states of all entity beans in the same
transaction context as the _ejbSelect<METHOD>_ method and whose abstract
schema types are accessed in the EJB QL query for the
_ejbSelect<METHOD>_ method are visible in the results of the
_ejbSelect<METHOD> method_ by invoking the _ejbStore_ method on those
entity bean instances.

The implementations of the select methods are
generated at the entity bean deployment time using the Container
Provider’s tools.

public <type> ejbHome<METHOD>(...);

The container
invokes the ejbHome<METHOD> method on an instance when a client invokes
a matching <METHOD> home method on the entity bean’s home interface. The
container must pick an instance that is in the pooled state (i.e., the
instance is not associated with any entity object identity) for the
execution of the ejbHome<METHOD> method. If there is no instance in the
pooled state, the container creates one and calls the setEntityContext
method on the instance before dispatching the home method.

After the ejbHome<METHOD> method completes,
the instance remains in the pooled state.

The container must invoke the ejbHome<METHOD>
method in the transaction context determined by the transaction
attribute of the matching <METHOD> home method, as described in EJB Core
Contracts and Requirements document link:Ejb.html#a3339[See EJB
3.2 Core Contracts and Requirements.
http://jcp.org/en/jsr/detail?id=345] Subsection “Container-Managed
Transaction Demarcation for Business Methods”.


 _public void ejbTimeout(...);_

The container invokes the _ejbTimeout_ method
on the instance when a timer with which the entity has been registered
expires. If there is no suitable instance in the ready state, the
container must activate an instance, invoking the _ejbActivate_ method
and transitioning it to the ready state.

The container invokes the _ejbTimeout_ method
in the context of a transaction determined by its transaction attribute.

[[a1342]]
==== Read-only Entity Beans

Compliant implementations of this
specification may optionally support read-only entity beans. A read-only
entity bean is an entity bean whose instances are not intended to be
updated and/or created by the application. Read-only beans are best
suited for situations where the underlying data never changes or changes
infrequently.

{empty}Containers that support read-only
beans do not call the _ejbStore_ method on them. The _ejbLoad_ method
should typically be called by the container when the state of the bean
instance is initially loaded from the database, or at designated refresh
intervals.link:#a3373[9]

{empty}If a read-only bean is used, the state
of such a bean should not be updated by the application, and the
behavior is unspecified if this occurs.link:#a3374[10]

Read-only beans are designated by
vendor-specific means that are outside the scope of this specification,
and their use is therefore not portable.

==== The EntityContext Interface

A container
provides the entity bean instances with an _EntityContext_ , which gives
the entity bean instance access to the instance’s context maintained by
the container. The _EntityContext_ interface has the following methods:

The _getEJBObject_ method returns the entity
bean’s remote interface.

The _getEJBHome_ method returns the entity
bean’s remote home interface.

The _getEJBLocalObject_ method returns the
entity bean’s local interface.

The _getEJBLocalHome_ method returns the
entity bean’s local home interface.

The _getCallerPrincipal_ method returns the
_java.security.Principal_ that identifies the invoker.

The _isCallerInRole_ method tests if the
entity bean instance’s caller has a particular role.

The _setRollbackOnly_ method allows the
instance to mark the current transaction such that the only outcome of
the transaction is a rollback.

The _getRollbackOnly_ method allows the
instance to test if the current transaction has been marked for
rollback.

The _getPrimaryKey_ method returns the entity
bean’s primary key.

The _getTimerService_ method returns the
_javax.ejb.TimerService_ interface.

The _getUserTransaction_ method returns the
_javax.transaction.UserTransaction_ interface. Entity bean instances
must not call this method.

The _lookup_ method enables the entity bean
to look up its environment entries in the JNDI naming context.

==== Operations Allowed in the Methods of the Entity Bean Class

Table
link:Ejb.html#a1367[See Operations Allowed in the Methods of an
Entity Bean] defines the methods of an entity bean class in which the
enterprise bean instances can access the methods of the
javax.ejb.EntityContext interface, the java:comp/env environment naming
context, resource managers, _TimerService_ and _Timer_ methods, the
_EntityManager_ and _EntityManagerFactory_ methods, and other enterprise
beans.

If an entity bean instance attempts to invoke
a method of the EntityContext interface, and the access is not allowed
in Table link:Ejb.html#a1367[See Operations Allowed in the
Methods of an Entity Bean], the container must throw the
java.lang.IllegalStateException.

If a entity bean instance attempts to invoke
a method of the _TimerService_ or _Timer_ interface and the access is
not allowed in Table link:Ejb.html#a1367[See Operations Allowed
in the Methods of an Entity Bean], the container must throw the
java.lang.IllegalStateException.

If an entity bean instance attempts to access
a resource manager, an enterprise bean, an entity manager or entity
manager factory, and the access is not allowed in Table
link:Ejb.html#a1367[See Operations Allowed in the Methods of an
Entity Bean], the behavior is undefined by the EJB architecture.

===



[[a1367]]Operations Allowed in the Methods of an Entity
Bean

Bean method

Bean method can perform the following
operations

constructor

-

setEntityContext

unsetEntityContext

EntityContext methods: getEJBHome,
getEJBLocalHome, lookup



JNDI access to java:comp/env

ejbCreate

EntityContext methods: getEJBHome,
getEJBLocalHome, getCallerPrincipal, getRollbackOnly, isCallerInRole,
setRollbackOnly, getTimerService, lookup

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

ejbPostCreate

EntityContext methods: getEJBHome,
getEJBLocalHome, getCallerPrincipal, getRollbackOnly, isCallerInRole,
setRollbackOnly, getEJBObject _, getEJBLocalObject,_ getPrimaryKey,
getTimerService, lookup

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

Timer service or Timer methods

EntityManagerFactory access

EntityManager access

ejbRemove

EntityContext methods: getEJBHome,
getEJBLocalHome, getCallerPrincipal, getRollbackOnly, isCallerInRole,
setRollbackOnly, getEJBObject _, getEJBLocalObject_ , getPrimaryKey,
getTimerService, lookup

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

Timer service or Timer methods

EntityManagerFactory access

EntityManager access

ejbHome

EntityContext methods: getEJBHome,
getEJBLocalHome, getCallerPrincipal, getRollbackOnly, isCallerInRole,
setRollbackOnly, getTimerService, lookup

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

ejbActivate

ejbPassivate

EntityContext methods: getEJBHome,
getEJBLocalHome, getEJBObject, getEJBLocalObject, getPrimaryKey,
getTimerService, lookup

JNDI access to java:comp/env

ejbLoad

ejbStore

EntityContext methods: getEJBHome,
getEJBLocalHome, getCallerPrincipal, getRollbackOnly, isCallerInRole,
setRollbackOnly, getEJBObject, getEJBLocalObject, getPrimaryKey,
getTimerService, lookup

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

Timer service or Timer methods

EntityManagerFactory access

EntityManager access

business method

from component interface

EntityContext methods: getEJBHome,
getEJBLocalHome, getCallerPrincipal, getRollbackOnly, isCallerInRole,
setRollbackOnly, getEJBObject, getEJBLocalObject, getPrimaryKey,
getTimerService, lookup

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

Timer service or Timer methods

EntityManagerFactory access

EntityManager access

ejbTimeout

EntityContext methods: getEJBHome,
getEJBLocalHome, getRollbackOnly, setRollbackOnly, getCallerPrincipal,
isCallerInRole, getEJBObject, getEJBLocalObject, getPrimaryKey,
getTimerService, lookup

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

Timer service or Timer methods

EntityManagerFactory access

EntityManager access

Additional restrictions:

The getRollbackOnly and setRollbackOnly
methods of the EntityContext interface should be used only in the
enterprise bean methods that execute in the context of a transaction.
The container must throw the java.lang.IllegalStateException if the
methods are invoked while the instance is not associated with a
transaction.

Reasons for disallowing operations:

Invoking the getEJBObject,
_getEJBLocalObject_ , and getPrimaryKey methods is disallowed in the
entity bean methods in which there is no entity object identity
associated with the instance.

Invoking the _getEJBObject_ and _getEJBHome_
methods is disallowed if the entity bean does not define a remote client
view.

Invoking the _getEJBLocalObject_ and
_getEJBLocalHome_ methods is disallowed if the entity bean does not
define a local client view.

Invoking the getRollbackOnly and
setRollbackOnly methods is disallowed in the entity bean methods for
which the container does not have a meaningful transaction context.

Accessing resource managers and enterprise
beans, including accessing the persistent state of an entity bean
instance, is disallowed in the entity bean methods for which the
container does not have a meaningful transaction context or client
security context.

[[a1446]]
==== Finder Methods

An entity bean’s
home interface defines one or more finder
methodslink:#a3375[11], one for each way to find an entity
object or collection of entity objects within the home. The name of each
finder method starts with the prefix “ _find_ ”, such as
_findLargeAccounts_ . The arguments of a finder method are used in the
implementation of the query for the finder method to locate the
requested entity objects.

Every finder method except
_findByPrimaryKey(key)_ must be associated with a _query_ element in the
deployment descriptor. The entity Bean Provider declaratively specifies
the EJB QL finder query and associates it with the finder method in the
deployment descriptor. A finder method is normally characterized by an
EJB QL query string specified in the _query_ element. EJB QL is
described in Chapter link:Ejb.html#a1840[See EJB QL: EJB 2.1
Query Language for Container-Managed Persistence Query Methods]. A
compliant implementation of this specification is required to support
EJB QL as defined in Chapter link:Ejb.html#a1840[See EJB QL: EJB
2.1 Query Language for Container-Managed Persistence Query Methods] for
use with finder methods.

In the case that both the remote home
interface and local home interface define a finder method with the same
name and argument types, the EJB QL query string specified by the
_query_ element defines the semantics of both methods.

===== Single-Object Finder Methods

Some finder
methods (such as findByPrimaryKey) are designed to return at most one
entity object. For single-object finders, the result type of a
find<METHOD>method defined in the entity bean’s remote home interface is
the entity bean’s remote interface, and the result type of the
find<METHOD>method defined in the entity bean’s local home interface is
the entity bean’s local interface.

The following code illustrates the definition
of a single-object finder defined on the remote home interface.

// Entity’s home interface

public interface AccountHome extends
javax.ejb.EJBHome \{

 ...

 Account findByPrimaryKey(AccountPrimaryKey
primkey)

 throws FinderException, RemoteException;

 ...

}

Note that a finder method defined on the
local home interface must not throw the _RemoteException_ .

In general, when defining a single-object
finder method other than _findByPrimaryKey_ , the entity Bean Provider
should be sure that the finder method will always return only a single
entity object. This may occur, for example, if the EJB QL query string
that is used to specify the finder query includes an equality test on
the entity bean’s primary key fields. If the entity Bean Provider uses
an unknown primary key class (see link:Ejb.html#a1833[See
Special Case: Unknown Primary Key Class]), the Bean Provider will
typically define the finder method as a multi-object finder.

Note that a single-object finder method may
return a null value. If the result set of the query consists of a single
null value, the container must return the null value as the result of
the method. If the result set of a query for a single-object finder
method contains more than one value (whether non-null, null, or a
combination), the container must throw the _FinderException_ from the
finder method. If the result set of the query contains no values, the
container must throw the _ObjectNotFoundException_ .

===== Multi-Object Finder Methods

Some finder
methods are designed to return multiple entity objects. For multi-object
finders defined on the entity bean’s local home interface, the result
type of the find<METHOD>method is a collection of objects implementing
the entity bean’s local interface. For multi-object finders defined on
the entity bean’s remote home interface, the result type of the
find<METHOD>method is a collection of objects implementing the entity
bean’s remote interface.

The Bean Provider uses the Java™ 2
java.util.Collection interface to define a collection type for the
result type of a finder method for an entity bean with container-managed
persistence.

The collection of values returned by the
container may contain duplicates if DISTINCT is not specified in the
SELECT clause of the query for the finder method.

The collection of values returned by the
container may contain null values if the finder method returns the
values of a cmr-field and null values are not eliminated by the query.

A portable client
program must use the PortableRemoteObject.narrow method to convert the
objects contained in the collections returned by a finder method on the
entity bean’s remote home interface to the entity bean’s remote
interface type.

The following is
an example of a multi-object finder method defined on the remote home
interface:

// Entity’s home interface

public interface AccountHome extends
javax.ejb.EJBHome \{

 ...

 java.util.Collection
findLargeAccounts(double limit)

 throws FinderException, RemoteException;

 ...

}



Note that if this finder method were defined
on the local home interface, it would not throw the _RemoteException_ .

[[a1479]]
==== Select Methods

Select methods
are query methods for use by the Bean Provider within an entity bean
instance. Unlike finder methods, select methods are not specified in the
entity bean’s home interface. A select method is an abstract method
defined by the Bean Provider on an entity bean class. A select method
must not be exposed in the home or component interface of an entity
bean.

The semantics of a select method, like those
of a finder method, are defined by an EJB QL query string. A select
method is similar to a finder method, but unlike a finder method, but it
can return values that correspond to any cmp- or cmr-field type.

Every select method must be associated with a
_query_  element in the deployment
descriptor. The entity Bean Provider declaratively specifies the EJB QL
query and associates it with the select method in the deployment
descriptor. A select method is normally characterized by an EJB QL query
string specified in the _query_ element. EJB QL is described in Chapter
link:Ejb.html#a1840[See EJB QL: EJB 2.1 Query Language for
Container-Managed Persistence Query Methods]. A compliant implementation
of this specification is required to support EJB QL as defined in
Chapter link:Ejb.html#a1840[See EJB QL: EJB 2.1 Query Language
for Container-Managed Persistence Query Methods] for use with select
methods.

Typically an ejbSelect<METHOD>method that
returns entity objects returns these as EJBLocalObjects. If the
ejbSelect<METHOD>method returns an EJBObject or collection of
EJBObjects, the Bean Provider must specify the value of the
_result-type-mapping_ element in the _query_ deployment descriptor
element for the select method as _Remote_ .

An ejbSelect<METHOD> is not based on the
identity of the entity bean instance on which it is invoked. However,
the Bean Provider can use the primary key of an entity bean as an
argument to an _ejbSelect<METHOD>_ to define a query that is logically
scoped to a particular entity bean instance.

The following table illustrates the semantics
of finder and select methods.

===



Comparison of Finder and Select Methods

[width="100%",cols="34%,33%,33%",options="header",]
|===
| |Finder methods
|Select methods
|method |
_find<METHOD>_ | _ejbSelect<METHOD>_

|visibility
|exposed to client
|internal to entity bean class

|instance
|arbitrary bean instance in pooled state
|instance: current instance (could be bean
instance in pooled state or ready state)

|return value
|EJBObjects or EJBLocalObjects of the same
type as the entity bean |EJBObjects,
EJBLocalObjects, or cmp-field types
|===

===== Single-Object Select Methods

Some select
methods are designed to return at most one value. In general, when
defining a single-object select method, the entity Bean Provider must be
sure that the select method will always return only a single object or
value. If the query specified by the select method returns multiple
values of the designated type, the container must throw the
FinderException.

Note that a single-object select method may
return a null value. If the result set of the query consists of a single
null value, the container must return the null value as the result of
the method. If the result set of a query for a single-object select
method contains more than one value (whether non-null, null, or a
combination), the container must throw the _FinderException_ from the
select method. If the result set of the query contains no values, the
contain must throw the _ObjectNotFoundException_ .

The Bean Provider will typically define a
select method as a multi-object select
method.

===== Multi-Object Select Methods

Some select methods are designed to return
multiple values. For these multi-object select methods, the result type
of the ejbSelect<METHOD>method is a collection of objects.

The Bean Provider
uses the Java™ 2 java.util.Collection interface or java.util.Set
interface to define a collection type for the result type of a select
method. The type of the elements of the collection is determined by the
type of the SELECT clause of the
corresponding EJB QL query. If the Bean Provider uses the
_java.util.Collection_ interface, the collection of values returned by
the container may contain duplicates if DISTINCT is not specified in the
SELECT clause of the query. If a query for a select method whose result
type is _java.util.Set_ does not specify
DISTINCT in its SELECT clause, the container
must interpret the query as if SELECT
DISTINCT had been specified.

The collection of values returned by the
container may contain null values if the select method returns the
values of a cmr-field or cmp-field and null values are not eliminated by
the query.

The following is
an example of a multi-object select method definition in the _OrderBean_
class:

// OrderBean implementation class

public abstract class OrderBean implements
javax.ejb.EntityBean\{

 ...

 public abstract java.util.Collection

 ejbSelectAllOrderedProducts(Customer
customer)

 throws FinderException;

 // internal finder method to find all
products ordered



==== Timer Notifications

An entity bean can be registered with the EJB
timer service for time-based event notifications if it implements the
_javax.ejb.TimedObject_ interface. The container invokes the bean
instance’s _ejbTimeout_ method when a timer for the bean has expired.
See link:Ejb.html#a3258[See Timer Service].

[[a1524]]
==== Standard Application Exceptions for Entities

The EJB
specification defines the following standard application exceptions:

javax.ejb.CreateException

javax.ejb.DuplicateKeyException

javax.ejb.FinderException

javax.ejb.ObjectNotFoundException

javax.ejb.RemoveException

This section describes the use of these
exceptions by entity beans with container-managed persistence.

===== CreateException

From the client’s
perspective, a CreateException (or a subclass of CreateException)
indicates that an application level error occurred during a
create<METHOD> operation. If a client receives this exception, the
client does not know, in general, whether the entity object was created
but not fully initialized, or not created at all. Also, the client does
not know whether or not the transaction has been marked for rollback.
(However, the client may determine the transaction status using the
UserTransaction interface or the _setRollbackOnly_ method of the
_EJBContext_ interface.)

Both the container and the Bean Provider may
throw the CreateException (or subclass of CreateException) from the
create<METHOD>, ejbCreate<METHOD> and ejbPostCreate<METHOD> methods to
indicate an application-level error from the create or initialization
operation. Optionally, the container or Bean Provider may mark the
transaction for rollback before throwing this exception.

The container or Bean Provider is encouraged
to mark the transaction for rollback only if data integrity would be
lost if the transaction were committed by the client. Typically, when a
_CreateException_ is thrown, it leaves the database in a consistent
state, allowing the client to recover. For example, the
_ejbCreate<METHOD>_ method may throw the _CreateException_ to indicate
that the some of the arguments to the _create<METHOD>_ method are
invalid.

The container treats the CreateException as
any other application exception. See Section
link:Ejb.html#a3227[See Container Provider Responsibilities].

===== DuplicateKeyException

The
DuplicateKeyException is a subclass of CreateException. It may be thrown
by the container to indicate to the client or local client that the
entity object cannot be created because an entity object with the same
key already exists. The unique key causing the violation may be the
primary key, or another key defined in the underlying database.

Normally, the container should not mark the
transaction for rollback before throwing the exception.

When the client or local client receives a
DuplicateKeyException, the client knows that the entity was not created,
and that the transaction has not typically been marked for rollback.

===== FinderException

From the client’s
perspective, a FinderException (or a subclass of FinderException)
indicates that an application level error occurred during the find
operation. Typically, the transaction has not been marked for rollback
because of the FinderException.

The container
throws the FinderException (or subclass of FinderException) from the
implementation of a finder or select method to indicate an
application-level error in the finder or select method. The container
should not, typically, mark the transaction for rollback before throwing
the FinderException.

The container treats the FinderException as
any other application exception. See Section
link:Ejb.html#a3227[See Container Provider
Responsibilities].

===== ObjectNotFoundException

The
ObjectNotFoundException is a subclass of FinderException. The container
throws the _ObjectNotFoundException_ from the implementation of a finder
or select method to indicate that the requested object does not exist.

Only single-object finder or select methods
(see Subsections link:Ejb.html#a1446[See Finder Methods] and
link:Ejb.html#a1479[See Select Methods]) should throw this
exception. Multi-object finder or select methods must not throw this
exception. Multi-object finder or select methods should return an empty
collection as an indication that no matching objects were found.

===== RemoveException

From the client’s
perspective, a RemoveException (or a subclass of RemoveException)
indicates that an application level error occurred during a remove
operation. If a client receives this exception, the client does not
know, in general, whether the entity object was removed or not. The
client also does not know if the transaction has been marked for
rollback. (However, the client may determine the transaction status
using the UserTransaction interface.)

The container or Bean Provider throws the
RemoveException (or subclass of RemoveException) from a remove method to
indicate an application-level error from the entity object removal
operation. Optionally, the container or Bean Provider may mark the
transaction for rollback before throwing this exception.

The container or Bean Provider is encouraged
to mark the transaction for rollback only if data integrity would be
lost if the transaction were committed by the client. Typically, when a
_RemoveException_ is thrown, it leaves the database in a consistent
state, allowing the client to recover.

The container
treats the RemoveException as any other application exception. See
Section link:Ejb.html#a3227[See Container Provider
Responsibilities].

[[a1554]]
==== Commit Options

The Entity Bean
protocol is designed to give the container the flexibility to select the
disposition of the instance state at transaction commit time. This
flexibility allows the container to optimally manage the association of
an entity object identity with the enterprise bean instances.

The container can select from the following
commit-time options:

Option A: The container caches a “ready”
instance between transactions. The container knows that the bean
instance has exclusive access to the state of the object in the
persistent storage. Therefore, the container does not have to
synchronize the instance’s state from the persistent storage at the
beginning of the next transaction or have to verify that the instance’s
state is in sync with the persistent storage at the beginning of the
next transaction.

Option B: The container caches a “ready”
instance between transactions. In contrast to Option A, in this option
the instance may not have exclusive access to the state of the object in
the persistent storage. Therefore, the container must synchronize the
instance’s state from the persistent storage at the beginning of the
next transaction if the instance’s state in the persistent storage has
changed. Containers using optimistic concurrency control strategies may
instead choose to rollback the transaction if this invariant has not
been met: The container must ensure that in order for a transaction to
be successfully committed, the transaction must only operate on instance
data that is in sync with the persistent storage at the beginning of the
transaction.

Option _C_ : The container does not cache a
“ready” instance between transactions. The container returns the
instance to the pool of available instances after a transaction has
completed.

Variants of these strategies that capture the
same semantics from the Bean Provider’s viewpoint may be employed, e.g.,
to optimize data access.

The following illustrative lazy loading
strategies are consistent with the intent of these requirements:

If _ejbLoad_ is called at the beginning of
the transaction without the instance’s persistent state having been
loaded from the persistent storage, the persistent state must be faulted
in when _ejbLoad_ causes the bean’s getter accessor methods to be
invoked. If the _ejbLoad_ method is empty, data may be faulted in as
needed in the course of executing the businesss methods of the bean.

If the instance’s persistent state is cached
between transactions, _ejbLoad_ need not be called and persistent data
need not be faulted in from the persistent storage (unless it has not
previously been accessed). In this case, because _ejbLoad_ has been
previously called when the instance was entered into the ready state for
the first time, and because the bean instance’s state is consistent with
its persistent state, there is no need to call _ejbLoad_ unless the
instance’s state in the persistent storage has changed. In this case,
the container must ensure that in order for the transaction to be
successfully committed, the instance’s persistent state was in sync with
the persistent storage at the beginning of the transaction.

The following table provides a summary of the
commit-time options.

===



Summary of Commit-Time Options



Write instance state to database

Instance stays

ready

Instance state remains valid

Option A

Yes

Yes

Yes

Option B

Yes

Yes

No

Option C

Yes

No

No

Note that the container synchronizes the
instance’s state with the persistent storage at transaction commit for
all three options.

The selection of the commit option is
transparent to the entity bean implementation—the entity bean will work
correctly regardless of the commit-time option chosen by the container.
The Bean Provider writes the entity bean in the same way.

 _Note: The Bean Provider relies on the
ejbLoad method to be invoked in order to resynchronize the bean’s
transient state with its persistent state. It is the responsibility of
the container to call the ejbLoad method at the beginning of a new
transaction if the bean instance’s persistent data has
changed.link:#a3376[12]_

==== Concurrent Access from Multiple Transactions

When writing the entity bean business
methods, the Bean Provider does not have to worry about concurrent
access from multiple transactions. The Bean Provider may assume that the
container will ensure appropriate
synchronization for entity objects that are
accessed concurrently from multiple transactions.

The container
typically uses one of the following implementation strategies to achieve
proper synchronization. (These strategies are illustrative, not
prescriptive.)

The container activates multiple instances of
the entity bean, one for each transaction in which the entity object is
being accessed. The transaction synchronization is performed by the
underlying database during the accessor method calls performed by the
business methods, the _ejbTimeout_ method, and by the _ejbLoad_ ,
_ejbCreate<METHOD>_ , _ejbStore_ , and _ejbRemove_ methods. The
commit-time options B and C in Subsection
link:Ejb.html#a1554[See Commit Options] apply to this type of
container.

===



Multiple Clients Can Access the Same Entity Object Using Multiple
Instances

image:EBOpt-35.png[image]

With this strategy, the type of lock acquired
by _ejbLoad_ or get accessor method (if a lazy loading cache management
strategy is used) leads to a trade-off. If _ejbLoad_ or the accessor
method acquires an exclusive lock on the instance's state in the
database, the throughput of read-only transactions could be impacted. If
_ejbLoad_ or the accessor method acquires a shared lock and the instance
is updated, then either _ejbStore_ or a set accessor method will need to
promote the lock to an exclusive lock (which may cause a deadlock if it
happens concurrently under multiple transactions), or, if the container
uses an optimistic cache concurrency control strategy, the container
will need to validate the state of the cache against the database at
transaction commit (which may result in a rollback of the transaction).

It is expected
that containers will provide deployment-time configuration options that
will allow control to be exercised over the logical transaction
isolation levels that their caching strategies provide.

The container acquires exclusive access to
the entity object’s state in the database. The container activates a
single instance and serializes the access from multiple transactions to
this instance. The commit-time option A in Subsection
link:Ejb.html#a1554[See Commit Options] applies to this type of
container.

===



Multiple Clients Can Access the Same Entity Object Using Single Instance

image:EBOpt-36.png[image]

[[a1596]]
==== Non-reentrant and Re-entrant Instances

An entity Bean
Provider can specify that an entity bean is non-reentrant. If an
instance of a non-reentrant entity bean executes a client request in a
given transaction context, and another request with the same transaction
context arrives for the same entity object, the container will throw an
exception to the second request. This rule allows the Bean Provider to
program the entity bean as single-threaded,
non-reentrant code.

The functionality of entity beans with
container-managed persistence may require loopbacks in the same
transaction context. An example of a loopback is when the client calls
entity object A, A calls entity object B, and B calls back A in the same
transaction context. The entity bean’s method invoked by the loopback
shares the current execution context (which includes the transaction and
security contexts) with the Bean’s method invoked by the client.

If the entity bean is specified as
non-reentrant in the deployment descriptor, the container must reject an
attempt to re-enter the instance via the entity bean’s component
interface while the instance is executing a business method. (This can
happen, for example, if the instance has invoked another enterprise
bean, and the other enterprise bean tries to make a
loopback call.) If the attempt is made to
reenter the instance through the remote interface, the container must
throw the _java.rmi.RemoteException_ to the caller. If the attempt is
made to reenter the instance through the local interface, the container
must throw the _javax.ejb.EJBException_ to the caller. The container
must allow the call if the Bean’s deployment descriptor specifies that
the entity bean is re-entrant.

Re-entrant entity
beans must be programmed and used with caution. First, the Bean Provider
must code the entity bean with the anticipation of a
loopback call. Second, since the container
cannot, in general, tell a loopback from a concurrent call from a
different client, the client programmer must be careful to avoid code
that could lead to a concurrent call in the same transaction context.

Concurrent calls in the same transaction
context targeted at the same entity object are illegal and may lead to
unpredictable results. Since the container cannot, in general,
distinguish between an illegal concurrent call and a legal loopback,
application programmers are encouraged to avoid using loopbacks. Entity
beans that do not need callbacks should be marked as non-reentrant in
the deployment descriptor, allowing the container to detect and prevent
illegal concurrent calls from clients.

=== Responsibilities of the Enterprise Bean Provider



This section describes the responsibilities
of an entity Bean Provider to ensure that an entity bean with
container-managed persistence can be deployed in any EJB container.

==== Classes and Interfaces

The entity Bean
Provider is responsible for providing the following class files:

Entity bean class and any dependent classes

Primary key class

Entity bean’s remote interface and entity
bean’s remote home interface, if the entity bean provides a remote
client view

Entity bean’s local interface and local home
interface, if the entity bean provides a local client view

The Bean Provider must provide a remote
interface and a remote home interface or a local interface and a local
home interface for the bean. The Bean Provider may provide a remote
interface, remote home interface, local interface, and local home
interface for the bean. Other combinations are not allowed.

==== Enterprise Bean Class

The following are
the requirements for an entity bean class:

The class must
implement, directly or indirectly, the javax.ejb.EntityBean interface.

The class may implement, directly or
indirectly, the _javax.ejb.TimedObject_ interface.

The class must be defined as public and must
be abstract. The class must be a top level class.

The class must define a public constructor
that takes no arguments.

The class must not define the finalize()
method.

The class may, but is not required to,
implement the entity bean’s component interfacelink:#a3377[13].
If the class implements the entity bean’s component interface, the class
must provide no-op implementations of the methods defined by that
interface. The container will never invoke these methods on the bean
instances at runtime.

The entity bean class must implement the
business methods, and the ejbCreate _<METHOD>_ and ejbPostCreate
_<METHOD>_ methods as described later in this section.

The entity bean class must implement the
ejbHome<METHOD> methods that correspond to the home business methods
specified in the bean’s home interface. These methods are executed on an
instance in the pooled state; hence they must not access state that is
particular to a specific bean instance (e.g., the accessor methods for
the bean’s abstract persistence schema must not be used by these
methods).

The entity bean class must implement the get
and set accessor methods of the bean’s abstract persistence schema as
_abstract_ methods.

The entity bean class may have superclasses
and/or superinterfaces. If the entity bean has superclasses, the
business methods, the ejbCreate _<METHOD>_ and ejbPostCreate _<METHOD>_
methods, and the methods of the EntityBean interface and/or the
_TimedObject_ interface may be implemented in the enterprise bean class
or in any of its superclasses.

The entity bean class is allowed to implement
other methods (for example helper methods invoked internally by the
business methods) in addition to the methods required by the EJB
specification.

The entity bean class does not implement the
finder methods. The implementations of the finder methods are provided
by the container.

The entity bean class must implement any
ejbSelect<METHOD> methods as abstract methods.

==== Dependent Value Classes

The following are
the requirements for a dependent value class:

The class must be defined as public and must
not be abstract.

The class must be serializable.

==== ejbCreate<METHOD> Methods

The entity bean
class must implement the ejbCreate<METHOD> methods that correspond to
the create<METHOD> methods specified in the entity bean’s home interface
or local home interface.

The entity bean class may define zero or more
ejbCreate<METHOD> methods whose signatures must follow these rules:

The method name must have ejbCreate as its
prefix.

The method must be declared as public.

The method must not be declared as final or
static.

The return type must be the entity bean’s
primary key type.

If the _ejbCreate<METHOD>_ method corresponds
to a _create<METHOD>_ on the entity bean’s remote home interface, the
method arguments and return value types must be legal types for
RMI-IIOP.

The _throws_ clause must define the
_javax.ejb.CreateException_ . The _throws_ clause may define arbitrary
application specific exceptions.

EJB 1.0 allowed the _ejbCreate_ method to
throw the java.rmi.RemoteException to indicate a non-application
exception. This practice was deprecated in EJB 1.1—an EJB 1.1 or EJB 2.0
or later compliant enterprise bean should throw the
_javax.ejb.EJBException_ or another _java.lang.RuntimeException_ to
indicate non-application exceptions to the container (see Section
link:Ejb.html#a3221[See System Exceptions]). The _ejbCreate_
method of an entity bean with cmp-version 2.x must not throw the
java.rmi.RemoteException..

==== ejbPostCreate<METHOD> Methods

For each
ejbCreate<METHOD> method, the entity bean class must define a matching
ejbPostCreate<METHOD> method, using the following rules:

The method name must have ejbPostCreate as
its prefix.

The method must be declared as public.

The method must not be declared as final or
static.

The return type must be _void_ .

The method arguments must be the same as the
arguments of the matching ejbCreate<METHOD> method.

The _throws_ clause may define arbitrary
application specific exceptions, including the
javax.ejb.CreateException.

EJB 1.0 allowed the _ejbPostCreate_ method to
throw the java.rmi.RemoteException to indicate a non-application
exception. This practice was deprecated in EJB 1.1—an EJB 1.1 or EJB 2.0
or later compliant enterprise bean should throw the
_javax.ejb.EJBException_ or another _java.lang.RuntimeException_ to
indicate non-application exceptions to the container (see Section
link:Ejb.html#a3221[See System Exceptions]). The _ejbPostCreate_
method of an entity bean with cmp-version 2.x must not throw the
java.rmi.RemoteException..

==== ejbHome<METHOD> Methods

The entity bean
class may define zero or more home methods whose signatures must follow
the following rules:

An _ejbHome<METHOD>_ method must exist for
every home _<METHOD>_ method on the entity bean’s remote home or local
home interface. The method name must have ejbHome as its prefix followed
by the name of the _<METHOD>_ method in which the first character has
been uppercased.

The method must be declared as public.

The method must not be declared as static.

If the _ejbHome<METHOD>_ method corresponds
to a home _<METHOD>_ on the entity bean’s remote home interface, the
method argument and return value types must be legal types for RMI-IIOP.

The _throws_ clause may define arbitrary
application specific exceptions. The _throws_ clause must not throw the
_java.rmi.RemoteException_ .

==== ejbSelect<METHOD> Methods

The entity bean
class may define one or more select methods whose signatures must follow
the following rules:

The method name must have ejbSelect as its
prefix.

The method must be declared as public.

The method must be declared as abstract.

The _throws_ clause must define the
_javax.ejb.FinderException_ . The _throws_ clause may define arbitrary
application specific exceptions.

==== Business Methods

The entity bean
class may define zero or more business methods whose signatures must
follow these rules:

The method names can be arbitrary, but they
must not start with ‘ _ejb_ ’ to avoid conflicts with the callback
methods used by the EJB architecture.

The business method must be declared as
public.

The method must not be declared as final or
static.

If the business method corresponds to a
method of the entity bean’s remote interface, the method argument and
return value types must be legal types for RMI-IIOP.

The _throws_ clause may define arbitrary
application specific exceptions.

EJB 1.0 allowed the business methods to throw
the java.rmi.RemoteException to indicate a non-application exception.
This practice was deprecated in EJB 1.1—an EJB 1.1 or EJB 2.0 or later
compliant enterprise bean should throw the _javax.ejb.EJBException_ or
another _java.lang.RuntimeException_ to indicate non-application
exceptions to the container (see Section link:Ejb.html#a3221[See
System Exceptions]).The business methods of an entity bean with
cmp-version 2.x must not throw the java.rmi.RemoteException.

==== Entity Bean’s Remote Interface

The following are
the requirements for the entity bean’s remote interface:

The interface
must extend the javax.ejb.EJBObject interface.

The methods
defined in the remote interface must follow the rules for RMI-IIOP. This
means that their argument and return value types must be valid types for
RMI-IIOP, and their _throws_ clauses must include the
java.rmi.RemoteException.

The remote interface is allowed to have
superinterfaces. Use of interface inheritance is subject to the RMI-IIOP
rules for the definition of remote interfaces.

For each method defined in the remote
interface, there must be a matching method in the entity bean’s class.
The matching method must have:

The same name.

The same number and types of its arguments,
and the same return type.

All the exceptions defined in the _throws_
clause of the matching method of the enterprise Bean class must be
defined in the _throws_ clause of the method of the remote interface.

The remote interface methods must not expose
local interface types, local home interface types, timer handles, or the
managed collection classes that are used for entity beans with
container-managed persistence as arguments or results.

==== Entity Bean’s Remote Home Interface

The following are
the requirements for the entity bean’s home interface:

The interface
must extend the javax.ejb.EJBHome interface.

The methods defined in this interface must
follow the rules for RMI-IIOP. This means that their argument and return
types must be of valid types for RMI-IIOP, and their _throws_ clauses
must include the java.rmi.RemoteException.

The remote home interface is allowed to have
superinterfaces. Use of interface inheritance is subject to the RMI-IIOP
rules for the definition of remote interfaces.

Each method defined in the remote home
interface must be one of the following:

A create method.

A finder method.

A home method.

Each create method must be named “
_create<METHOD>_ ”, e.g. createLargeAccounts. Each create method name
must match one of the ejbCreate<METHOD> methods defined in the
enterprise bean class. The matching ejbCreate<METHOD> method must have
the same number and types of its arguments. (Note that the return type
is different.)

The return type for a create<METHOD> method
must be the entity bean’s remote interface type.

All the exceptions defined in the _throws_
clause of the matching ejbCreate _<METHOD>_ and ejbPostCreate _<METHOD>_
methods of the enterprise bean class must be included in the _throws_
clause of the matching create method of the home interface (i.e., the
set of exceptions defined for the create method must be a superset of
the union of exceptions defined for the ejbCreate _<METHOD>_ and
ejbPostCreate _<METHOD>_ methods).

The _throws_ clause of a create _<METHOD>_
method must include the javax.ejb.CreateException.

Each finder method must be named “ _find_
<METHOD>” (e.g. findLargeAccounts).

The return type for a find<METHOD> method
must be the entity bean’s remote interface type (for a single-object
finder), or a collection thereof (for a multi-object finder).

The remote home interface must always include
the findByPrimaryKey method, which is always a single-object finder. The
method must declare the primary key class as the method argument.

The _throws_ clause of a finder method must
include the javax.ejb.FinderException.

Home methods can have arbitrary names, but
they must not start with “create”, “find”, or “ _remove_ ”. Their
argument and return types must be of valid types for RMI-IIOP, and their
_throws_ clauses must include the java.rmi.RemoteException. The matching
ejbHome method specified in the entity bean class must have the same
number and types of arguments and must return the same type as the home
method as specified in the remote home interface of the bean.

The remote home interface methods must not
expose local interface types, local home interface types, timers or
timer handles, or the managed collection classes that are used for
entity beans with container-managed persistence as arguments or results.

==== Entity Bean’s Local Interface

The following are
the requirements for the entity bean’s local interface:

The interface
must extend the javax.ejb.EJBLocalObject interface.

For each method defined in the local
interface, there must be a matching method in the entity bean’s class.
The matching method must have:

The same name.

The same number and types of its arguments,
and the same return type.

All the exceptions defined in the _throws_
clause of the matching method of the enterprise Bean class must be
defined in the _throws_ clause of the method of the local interface.

==== Entity Bean’s Local Home Interface

The following are
the requirements for the entity bean’s local home interface:

The interface
must extend the javax.ejb.EJBLocalHome interface.

Each method defined in the home interface
must be one of the following:

A create method.

A finder method.

A home method.

Each create method must be named “
_create<METHOD>_ ”, e.g. createLargeAccounts. Each create method name
must match one of the ejbCreate<METHOD> methods defined in the
enterprise bean class. The matching ejbCreate<METHOD> method must have
the same number and types of its arguments. (Note that the return type
is different.)

The return type for a create<METHOD> method
on the local home interface must be the entity bean’s local interface
type.

All the exceptions defined in the _throws_
clause of the matching ejbCreate _<METHOD>_ and ejbPostCreate _<METHOD>_
methods of the enterprise bean class must be included in the _throws_
clause of the matching create method of the local home interface (i.e.,
the set of exceptions defined for the create method must be a superset
of the union of exceptions defined for the ejbCreate _<METHOD>_ and
ejbPostCreate _<METHOD>_ methods).

The _throws_ clause of a create _<METHOD>_
method must include the javax.ejb.CreateException.

Each finder method must be named “ _find_
<METHOD>” (e.g. findLargeAccounts).

The return type for a find<METHOD> method
defined on the local home interface must be the entity bean’s local
interface type (for a single-object finder), or a collection thereof
(for a multi-object finder).

The local home interface must always include
the findByPrimaryKey method, which is always a single-object finder. The
method must declare the primary key class as the method argument.

The _throws_ clause of a finder method must
include the javax.ejb.FinderException.

Home methods can have arbitrary names, but
they must not start with “create”, “find”, or “ _remove_ ”. The matching
ejbHome method specified in the entity bean class must have the same
number and types of arguments and must return the same type as the home
method as specified in the home interface of the bean. The _throws_
clause of a home method defined on the local home interface must not
include the java.rmi.RemoteException.

[[a1725]]
==== Entity Bean’s Primary Key Class

The Bean Provider
must specify a primary key class in the deployment descriptor.

The primary key
type must be a legal Value Type in RMI-IIOP.

The class must provide suitable
implementation of the hashCode() and equals(Object other) methods to
simplify the management of the primary keys by the container.

==== Entity Bean’s Deployment Descriptor

The Bean Provider must specify the
relationships in which the entity beans participate in the
_relationships_ element.

The Bean Provider must provide unique names
to designate entity beans as follows, and as described in
link:Ejb.html#a1013[See The Bean Provider’s View of the
Deployment Descriptor].

The Bean Provider must specify unique names
for entity beans which are defined in the ejb-jar file by using the
ejb-name element.

The Bean Provider must specify a unique
abstract schema name for an entity bean using the _abstract-schema-name_
deployment descriptor element.

The Bean Provider
must define a query for each finder or select method except
_findByPrimaryKey(key)_ . Typically this will be provided as the content
of the ejb-ql element contained in the query element for the entity
bean. The syntax of EJB QL is defined in Chapter
link:Ejb.html#a1840[See EJB QL: EJB 2.1 Query Language for
Container-Managed Persistence Query Methods].

Since EJB QL query strings are embedded in
the deployment descriptor, which is an XML document, it may be necessary
to encode the following characters in the query string: “ _>_ ”, “ _<_
“.

=== The Responsibilities of the Container Provider



This section
describes the responsibilities of the Container Provider to support
entity beans. The Container Provider is responsible for providing the
deployment tools, and for managing the entity beans at runtime,
including their persistent state and relationships.

Because the EJB specification does not define
the API between deployment tools and the container, we assume that the
deployment tools described in this section are provided by the Container
Provider. Alternatively, the deployment tools may be provided by a
different vendor who uses the container vendor’s specific API.

==== Generation of Implementation Classes

The deployment
tools provided by the Container Provider are responsible for the
generation of additional classes when the entity bean is deployed. The
tools obtain the information that they need for generation of the
additional classes by introspecting the classes and interfaces provided
by the Bean Provider and by examining the entity bean’s deployment
descriptor.

The deployment tools must generate the
following classes:

A class that implements the entity bean’s
remote home interface (i.e., the entity EJBHome class).

A class that implements the entity bean’s
remote interface (i.e., the entity EJBObject class).

A class that implements the entity bean’s
local home interface (i.e., the entity EJBLocalHome class).

A class that implements the entity bean’s
local interface (i.e., the EJBLocalObject class).

A class that implements the entity bean class
(i.e., a concrete class corresponding to the abstract entity bean class
that was provided by the Bean Provider).

The deployment tools may also generate a
class that mixes some container-specific code with the entity bean
class. The code may, for example, help the container to manage the
entity bean instances at runtime. Tools can use subclassing, delegation,
and code generation.

The deployment tools may also allow
generation of additional code that wraps the business methods and that
is used to customize the business logic for an existing operational
environment. For example, a wrapper for a debit function on the Account
bean may check that the debited amount does not exceed a certain limit,
or perform security checking that is specific to the operational
environment.

==== Enterprise Bean Class

The following are
the requirements for a concrete entity bean class:

The class must extend the abstract entity
bean class provided by the Bean Provider.

The class must be defined as public and must
not be abstract.

The class must define a public constructor
that takes no arguments.

The class must implement the get and set
accessor methods of the bean’s abstract persistence schema.

The class must not define the _finalize_
method.

The entity bean class must implement the
_ejbFind<METHOD>_ methods.

The entity bean class must implement the
_ejbSelect<METHOD>_ methods.

The entity bean class is allowed to implement
other methods in addition to the methods required by the EJB
specification.

==== ejbFind<METHOD> Methods

For each
find<METHOD> method in the remote home
interface or local home interface of the entity bean, there must be a
corresponding _ejbFind<METHOD>_  method with
the same argument types in the concrete entity bean class.

The method name must have ejbFind as its
prefix.

The method must be declared as public.

If the _ejbFind<METHOD>_ method corresponds
to a _find<METHOD>_ on the entity bean’s remote home interface, the
method argument and return value types must be legal types for RMI-IIOP.

The return type of an _ejbFind<METHOD>_
method must be the entity bean’s primary key type, or a collection of
primary keys.

The _throws_ clause must define the
_javax.ejb.FinderException_ . The _throws_
clause may define arbitrary application specific exceptions.

Every finder method except
_ejbFindByPrimaryKey(key)_ is specified in the _query_ deployment
descriptor element for the entity. The container must use the EJB QL
query string that is the content of the _ejb-ql_ element or the
descriptive query specification contained in the _description_ element
as the definition of the query of the corresponding ejbFind<METHOD>
method.

==== ejbSelect<METHOD> Methods

For each
ejbSelect<METHOD> method in the abstract entity bean class, there must
be a method with the same argument and result types in the concrete
entity bean class.

Every select method is specified in a _query_
deployment descriptor element for the entity. The container must use the
EJB QL query string that is the content of the _ejb-ql_ element or the
descriptive query specification that is contained in the _description_
element as the definition of the query of the corresponding
ejbSelect<METHOD>method.

The container must use the contents of the
_query_ element, the corresponding EJB QL string and the type of the
values selected as specified by the SELECT clause to determine the type
of the values returned by a select method.

The container must ensure that there are no
duplicates returned by a select method if the return type is
java.util.Set.

==== Entity EJBHome Class

The entity
EJBHome class, which is generated by deployment tools, implements the
entity bean’s remote home interface. This class implements the methods
of the javax.ejb.EJBHome interface, and the type-specific create and
finder methods specific to the entity bean.

The implementation of each create<METHOD>
method invokes a matching ejbCreate<METHOD> method, followed by the
matching ejbPostCreate<METHOD> method, passing the create<METHOD>
parameters to these matching methods.

The implementation of the remove methods
defined in the javax.ejb.EJBHome interface must activate an instance (if
an instance is not already in the ready state) and invoke the ejbRemove
method on the instance.

The implementation of each find<METHOD>
method invokes a matching ejbFind<METHOD> method. The implementation of
the find<METHOD> method must create an entity object reference for the
primary key returned from the ejbFind<METHOD> and return the entity
object reference to the client. If the ejbFind<METHOD> method returns a
collection of primary keys, the implementation of the find<METHOD>
method must create a collection of entity object references for the
primary keys and return the collection to the client.

The implementation of each <METHOD> home
method invokes a matching ejbHome<METHOD> method (in which the first
character of _<METHOD>_ is uppercased in the name of the ejbHome<METHOD>
method), passing the parameters of the <METHOD> method to the matching
ejbHome<METHOD>method.

==== Entity EJBObject Class

The entity
EJBObject class, which is generated by deployment tools, implements the
entity bean’s remote interface. It implements the methods of the
javax.ejb.EJBObject interface and the remote business methods specific
to the entity bean.

The implementation of the remove method
(defined in the javax.ejb.EJBObject interface) must activate an instance
(if an instance is not already in the ready state) and invoke the
ejbRemove method on the instance.

The implementation of each remote business
method must activate an instance (if an instance is not already in the
ready state) and invoke the matching business method on the instance.

==== Entity EJBLocalHome Class

The entity
EJBLocalHome class, which is generated by deployment tools, implements
the entity bean’s local home interface. This class implements the
methods of the javax.ejb.EJBLocalHome interface, and the type-specific
create and finder methods specific to the entity bean.

The implementation of each create<METHOD>
method invokes a matching ejbCreate<METHOD> method, followed by the
matching ejbPostCreate<METHOD> method, passing the create<METHOD>
parameters to these matching methods.

The implementation of the remove method
defined in the javax.ejb.EJBLocalHome interface must activate an
instance (if an instance is not already in the ready state) and invoke
the ejbRemove method on the instance.

The implementation of each find<METHOD>
method invokes a matching ejbFind<METHOD> method. The implementation of
the find<METHOD> method must create a local entity object reference for
the primary key returned from the ejbFind<METHOD> and return the local
entity object reference to the local client. If the ejbFind<METHOD>
method returns a collection of primary keys, the implementation of the
find<METHOD> method must create a collection of local entity object
references for the primary keys and return the collection to the local
client.

The implementation of each <METHOD> home
method invokes a matching ejbHome<METHOD> method (in which the first
character of _<METHOD>_ is uppercased in the name of the ejbHome<METHOD>
method), passing the parameters of the <METHOD> method to the matching
ejbHome<METHOD> method.

==== Entity EJBLocalObject Class

The entity
EJBLocalObject class, which is generated by deployment tools, implements
the entity bean’s local interface. It implements the methods of the
javax.ejb.EJBLocalObject interface and the local business methods
specific to the entity bean.

The implementation of the remove method
(defined in the javax.ejb.EJBLocalObject interface) must activate an
instance (if an instance is not already in the ready state) and invoke
the ejbRemove method on the instance.

The implementation of each local business
method must activate an instance (if an instance is not already in the
ready state) and invoke the matching business method on the instance.

==== Handle Class

The deployment
tools are responsible for implementing the handle class for the entity
bean. The handle class must be serializable by the Java Serialization
protocol.

As the handle class is not entity bean
specific, the container may, but is not required to, use a single class
for all deployed entity beans.

==== Home Handle Class

The deployment
tools responsible for implementing the home
handle class for the entity bean. The handle
class must be serializable by the Java Serialization protocol.

Because the home handle class is not entity
bean specific, the container may, but is not required to, use a single
class for the home handles of all deployed entity beans.

==== Metadata Class

The deployment
tools are responsible for implementing the class that provides metadata
information to the remote client view contract. The class must be a
valid RMI-IIOP Value Type, and must implement the javax.ejb.EJBMetaData
interface.

Because the metadata class is not entity bean
specific, the container may, but is not required to, use a single class
for all deployed enterprise beans.

==== Instance’s Re-entrance

The container runtime must enforce the rules
defined in Section link:Ejb.html#a1596[See Non-reentrant and
Re-entrant Instances].

==== Transaction Scoping, Security, Exceptions

The container runtime must follow the rules
on transaction scoping and
exception handling described in Chapters 9
and link:Ejb.html#a3210[See Exception Handling]. The container
runtime must follow the rules on security
checking described in the EJB Core Contracts and Requirements document
link:Ejb.html#a3339[See EJB 3.2 Core Contracts and Requirements.
http://jcp.org/en/jsr/detail?id=345] Chapter “Security Management”.

==== Implementation of Object References

The container
should implement the distribution protocol between the remote client and
the container such that the object references of the remote home and
remote interfaces used by entity bean clients are usable for a long
period of time. Ideally, a remote client should be able to use an object
reference across a server crash and restart. An object reference should
become invalid only when the entity object has been removed, or after a
reconfiguration of the server environment (for example, when the entity
bean is moved to a different EJB server or container).

The motivation for this is to simplify the
programming model for the entity bean client. While the client code
needs to have a recovery handler for the system exceptions thrown from
the individual method invocations on the remote home and remote
interface, the client should not be forced to re-obtain the object
references.

==== EntityContext

The container must implement the
EntityContext.getEJBObject method such that
the bean instance can use the Java language cast to convert the returned
value to the entity bean’s remote interface type. Specifically, the bean
instance does not have to use the PortableRemoteObject.narrow method for
the type conversion.

[[a1820]]
=== Primary Keys



The container
must be able to manipulate the primary key type of an entity bean.
Therefore, the primary key type for an entity bean with
container-managed persistence must follow the rules in this subsection,
in addition to those specified in Subsection
link:Ejb.html#a1725[See Entity Bean’s Primary Key Class].

There are two ways to specify a primary key
class for an entity bean with container-managed persistence:

Primary key that maps to a single field in
the entity bean class.

Primary key that maps to multiple fields in
the entity bean class.

The second method is necessary for
implementing compound keys, and the first method is convenient for
single-field keys. Without the first method, simple types such as String
would have to be wrapped in a user-defined class.

==== Primary Key That Maps to a Single Field in the Entity Bean Class

The Bean Provider
uses the primkey-field element of the
deployment descriptor to specify the container-managed field of the
entity bean class that contains the primary key. The field’s type must
be the primary key type.

==== Primary Key That Maps to Multiple Fields in the Entity Bean Class

The primary key
class must be public, and must have a public constructor with no
parameters.

All fields in the primary key class must be
declared as public.

The names of the fields in the primary key
class must be a subset of the names of the container-managed fields.
(This allows the container to extract the primary key fields from an
instance’s container-managed fields, and vice versa.)

[[a1833]]
==== Special Case: Unknown Primary Key Class

In special
situations, the entity Bean Provider may choose not to specify the
primary key class or the primary key fields for an entity bean with
container-managed persistence. This case usually happens when the entity
bean does not have a natural primary key, and/or the Bean Provider wants
to allow the Deployer using the Container Provider’s tools to select the
primary key fields at deployment time. The entity bean’s primary key
type will usually be derived from the primary key type used by the
underlying database system that stores the entity objects. The primary
key used by the database system may not be known to the Bean Provider.

In this special case, the type of the
argument of the findByPrimaryKey method must be declared as
java.lang.Object. The Bean Provider must specify the primary key class
in the deployment descriptor as of the type java.lang.Object.

When defining the primary key for the
enterprise bean, the Deployer using the Container Provider’s tools will
typically add additional container-managed fields to the concrete
subclass of the entity bean class (this typically happens for entity
beans that do not have a natural primary key, and the primary keys are
system-generated by the underlying database system that stores the
entity objects). In this case, the container must generate the primary
key value when the entity bean instance is created (and before
_ejbPostCreate_ is invoked on the instance.)

The primary key class is specified at
deployment time in the situations when the Bean Provider develops an
entity bean that is intended to be used with multiple back-ends that
provide persistence, and when these multiple back-ends require different
primary key structures.

Use of entity beans with a deferred primary
key type specification limits the client application programming model,
because the clients written prior to deployment of the entity bean may
not use, in general, the methods that rely on the knowledge of the
primary key type.

The implementation of the enterprise bean
class methods must be done carefully. For example, the methods should
not depend on the type of the object returned from
_EntityContext.getPrimaryKey,_ because the return type is determined by
the Deployer after the EJB class has been written.
